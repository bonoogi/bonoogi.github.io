<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Swift] Combine 테스트 하기 | Hell yeah, World</title><meta name=keywords content><meta name=description content="TestScheduler 정도는 만들어줬으면 좋았을텐데"><meta name=author content><link rel=canonical href=https://bonoogi.github.io/posts/2022-02-20-testing-combine/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bonoogi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bonoogi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bonoogi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bonoogi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bonoogi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-DKVGJN68MW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DKVGJN68MW",{anonymize_ip:!1})}</script><meta property="og:title" content="[Swift] Combine 테스트 하기"><meta property="og:description" content="TestScheduler 정도는 만들어줬으면 좋았을텐데"><meta property="og:type" content="article"><meta property="og:url" content="https://bonoogi.github.io/posts/2022-02-20-testing-combine/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-20T23:19:41+09:00"><meta property="article:modified_time" content="2022-02-20T23:19:41+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Swift] Combine 테스트 하기"><meta name=twitter:description content="TestScheduler 정도는 만들어줬으면 좋았을텐데"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bonoogi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Swift] Combine 테스트 하기","item":"https://bonoogi.github.io/posts/2022-02-20-testing-combine/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Swift] Combine 테스트 하기","name":"[Swift] Combine 테스트 하기","description":"TestScheduler 정도는 만들어줬으면 좋았을텐데","keywords":[],"articleBody":"원래는 이전 글에서 Combine Scheduler에 대해 좀 더 알아보는 글을 쓰려고 했는데, 방향에 가닥이 잡히질 않아 다른것부터 쓰기로 했다. 뭔고 하니, 바로 Combine 코드를 단위 테스트하는 방법이다. 현재 개발중인 프로젝트에서는 많은 코드를 Combine 기반으로 작성하고 있기 때문에 테스트 코드 역시 Combine에 맞춰서 구현하게 된다. 그렇다면 어떻게 Combine 코드를 테스트할 수 있을까? 공통점 하나와 차이점 하나로 설명해보겠다.\n공통점: setUp과 tearDown Combine 테스트라면 당연하게도 Publisher를 구독하고 값을 받거나 종료 이벤트를 받는 시점에 받은 값을 검증해야 할 것이다. 그렇다면 결과적으로 Publisher를 구독했을 때 반환되는 Cancellable에 대한 처리가 필요하다는 것이다. 만약 이런 부분을 간과한다면, 어딘가에서부터 이유를 알 수 없이 깨지는 테스트 케이스가 발생하게 될 것이다.\nimport XCTest import Combine  class CombineTest: XCTestCase {  // 초기화  var subscriptions = Set()   override func tearDown() {  // 종료된 테스트 케이스의 Cancellable에 대해 초기화 처리  subscriptions = []  } } 차이점: 동기냐 비동기냐 사실 Combine이나 XCTest 프레임워크 상에서 별도로 Combine만을 위한 테스트 도구를 제공하지는 않는다. 예를 들어, RxSwift에는 TestScheduler가 있어 가상으로 이벤트의 시간을 조정할 수 있다. 그렇기 때문에 특히나 비동기로 이루어지는 작업에 대한 테스트에 대한 기대값을 조정하기에 편하다. 하지만 Combine에는 그런게 없다. 기존에 제공하는 도구로도 충분히 모든 것을 테스트할 수 있다는 자신감이 아닌가 싶다(물론 실제로도 기존 도구로 모든 테스트가 가능).\n동기 테스트 동기적인 동작에 대한 테스트는 간단하다. 간략하게 순서로 얘기하자면 다음과 같다.\n 테스트할 결과값을 받아와 저장하는 변수와 테스트하고자 하는 성공/실패 기대값을 준비한다. 테스트하고자 하는 Publisher를 준비한다. Publisher를 구독하고 값을 받는 클로져(receiveValue or receiveCompletion)에서 결과값을 저장하는 변수에 값을 저장한다. 테스트하고자 하는 기대값과 비교한다.  만약 생성자를 통해 주어진 인자를 소문자화하는 커스텀 Publisher인 LowerCased가 있다고 하자. 그렇다면 이 Publisher에 대해서는 어떻게 테스트해야할까? 다음 코드가 아마 힌트가 될 것이다.\n// Publisher.LowerCased가 제대로 주어진 값을 소문자화하는지 테스트 func test_lowerCased() {  // 1 - 결과값을 저장할 변수와 기대값 변수 선언  var result: String = \"\"  let expect: String = \"foo\"   // 2 - 테스트할 Publisher  Publisher.LowerCased(\"FOO\")  .sink(receiveValue: {  // 3 - 결과값 저장  result = $0  })  .store(in: \u0026subscriptions)   // 4 - 결과 검증  XCTAssertEqual(result, expect) } 위에서 얘기한 순서에 해당하는 부분에 주석으로 숫자를 남겨놨다. 이 테스트케이스의 경우 모든 것이 동기적으로 동작할 것이라는 것이 기대되기 때문에 결과값을 클로져 내부에서 받아온다고 하더라도 신경쓸 필요가 없다. 그저 순차적으로 동작할 것을 기대하고 테스트 코드를 작성하면 되는 것이다.\n그렇다면 만약 ViewModel과 같은 역할을 하는 클래스를 테스트한다면 어떻게 해야할까? 이 경우에도 크게 다르지 않다. 아래와 같은 클래스가 있다고 생각해보자. 아래 클래스는 문자열을 입력하면 lowerCased 변수에 입력한 문자열을 소문자로 변환해 저장하는 클래스이다.\nclass LowerCaseViewModel: ObservableObject {  @Published private(set) var lowerCased: String = \"\"   func setValue(_ text: String) {  lowerCased = text.lowerCased()  } } 이 경우 다음과 같은 테스트가 가능할 것이다.\nclass LowerCaseViewModelTest: XCTestCase {  var viewModel: LowerCaseViewModel!  var subscriptions = Set()   override func setUp() {  viewModel = LowerCaseViewModel()  }   override func tearDown() {  subscriptions = []  }   func test_lowerCased() {  var result: String = \"\"  let expected: String = \"foo\"   viewModel.$lowerCased  .sink(receiveValue: {  result = $0  })  .store(in: \u0026subscriptions)   viewModel.setValue(\"FOO\")   XCTAssertEqual(result, expected)  } } viewModel.$lowerCased는 실제로는 [\"\", “foo”]의 두 개 값이 방출되고, 딱히 종결이벤트가 발생하지 않지만 해당 테스트 케이스는 동기적 이벤트 발생에 대한 흐름을 쫓고 있기 때문에 결과값이 기대값인 “foo\"와 동일하기 때문에 의도한대로 성공하는 테스트 케이스가 되는 것이다.\n그렇다면 이번엔 Combine의 비동기 동작은 어떻게 테스트할 수 있는지 알아보자.\n비동기 테스트 위의 동기 동작에 대한 테스트 코드를 보면 사실 일반적인 테스트 코드를 작성하는 것과 그렇게까지 큰 차이가 없다는 것을 알 수 있다. 그렇다면 비동기 동작에 대한 테스트는? 그렇다. 흔히 활용하는 completionHandler에 대한 테스트와 비슷하게 처리할 수 있다. 바로 XCTestExpectation을 사용하는 것이다. 그 전에, 일단 아래와 같은 ViewModel 클래스가 있다고 가정해보자.\nclass FooViewModel: ObservableObject {  private let fetcher = BarFetcher()  @Publisher private(set) var fetchedData: String = \"\"   func fetch(for keyword: String) {  fetcher.fetchAsync(for: keyword)  .assign(to: \u0026$fetchedData)  } } 어떤 키워드를 입력하면 어딘가로부터 키워드에 맞는 데이터를 가져와 fetchedData에 해당 데이터를 넣어주느 동작을 하는 ViewModel이다. 이 경우에는 키워드에 맞는 데이터를 비동기적으로 가져오는 동작밖에 할 수 없기 때문에 위의 동기 테스트 코드로는 처리할 수 없다. 하지만 이를 위해 위에서 언급한 XCTestExpectation이 존재하는 것이다. 간략한 사용방법은 아래 코드로 알 수 있으나, 자세하게 알고 싶다면 애플 개발자 문서를 찾아보자.\nfunc test_fetchAsync() {  var result = [String]()  let expected = [\"some text data for keyword\"]   // 비동기 작업에 대해 대기하도록 하는 XCTestExpectation 생성  let expectation = self.expectation(description: #function)  viewModel.$fetchedData  .dropFirst()  .prefix(1)  .sink(  receiveCompletion: { _ in  // 이벤트 종료와 함께 expectation에 대기 종료할 것을 알린다  expectation.fulfill()  },  receiveValue: {  result.append($0)  }  )  .store(in: \u0026subscriptions)   viewModel.fetch(for: \"keyword\")   // XCTestExpectation의 종료 메시지를 대기하도록 하는 명령. 최대 5초간 기다리도록 지정.  waitForExpectations(timeout: 5, handler: nil)   XCTAssertEqual(result, expected) } XCTestExpectation의 사용법은 주석으로 대강 알아볼 수 있을 것이다. 여기서 확인해야하는 것은 viewModel.$fetchedData의 뒤에 달라붙어있는 dropFirst()와 prefix(1)이다. 그렇다면 왜 이런 연산자를 사용해야 하는걸까?\n첫번째로 dropFirst를 쓴 이유는 다음과 같다. viewModel.$fetchedData의 경우 초기값이 있는 Publisher다. 이 경우 dropFirst가 없으면 result가 초기값까지 받아 배열에 넣기 때문에 expected 값과 비교하면 테스트 실패라고 나올 것이다. 물론 최종 결과값만 보고 비교해도 상관없다면 기대값과 결과값을 [String]이 아닌 String 타입으로 놓고 비교하면 될 일이다. 하지만 Combine이라는 것은 결국 이벤트 스트림에 대한 것이고, 이에 대해 테스트하기 위해서는 이벤트 스트림 자체에 대한 검증이 필요해지는 것이다(그래서 적절한 TestScheduler가 있으면 더 좋다). 이런 것들은 명시적/암시적으로 환기해가면서 주지하지 않으면 금방 까먹을 수 있기 때문에 개인적으로 위와 같은 패턴을 즐겨 쓰는 편이다.\n두번째로 prefix를 쓴 이유는 다음과 같다. viewModel.$fetchedData는 ViewModel 자체가 deinit되지 않는 한 이벤트 스트림이 종결될 일이 없다. 이벤트 스트림이 종결되지 않는다면 적절한 시점에 expectation.fulfill이 호출되지 않기 때문에 waitForExpectations로 지정한 시간제한에 걸리고 만다. 이런 일을 피하기 위해서는 prefix와 같은 연산자를 통해 이벤트 스트림에 대한 추적을 얼마만큼 할 것인지 지정해야 한다.\n위의 두 연산자를 반드시 써야한다는 것이 아니다. 비동기 동작에 대한 테스트를 할때는 이벤트 스트림에 대한 검증을 해야한다는 것을 잊으면 안된다는 것이다. 특히나 ViewModel과 같은 클래스는 뷰의 상태에 직접적으로 관여하는 경우가 많기 때문에 더더욱 이를 유념해야 한다. 예를 들어 뷰 안에 스위치가 있고, 이 스위치를 전환할때 어떤 비동기 동작을 진행한 후 스위치와 바인딩된 Bool 값이 변경된다고 생각해보자. 비동기 동작을 한 번 진행할때 스위치에 바인딩된 Bool값이 두번 세번 네번 변경된다? 그러면 사용자는 단 한번의 상호작용을 했을 뿐인데 그에 대한 결과를 두번 이상 목격하게 되고, 결과적으로 혼란을 겪게 될 것이다. 이 역시 중요한 버그라고 할 수 있으니 꼭 검증해야 하는 요소라고 할 수 있다.\n결론 오늘은 Combine의 스케쥴러가 아닌 테스트에 대해 알아봤다. 일반적인 테스트 코드 작성법과 크게 다르지 않지만, 어떤 경우에는 단순 값에 대한 검증이 아니라 이벤트 스트림에 대한 검증을 해야한다는 차이가 있었다. 이것만 유념한다면 Combine 코드에 대한 테스트 케이스 작성 및 검증에 큰 어려움을 겪지는 않을 것이다.\n","wordCount":"1019","inLanguage":"en","datePublished":"2022-02-20T23:19:41+09:00","dateModified":"2022-02-20T23:19:41+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bonoogi.github.io/posts/2022-02-20-testing-combine/"},"publisher":{"@type":"Organization","name":"Hell yeah, World","logo":{"@type":"ImageObject","url":"https://bonoogi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bonoogi.github.io/ accesskey=h title="Hell yeah, World (Alt + H)">Hell yeah, World</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[Swift] Combine 테스트 하기</h1><div class=post-description>TestScheduler 정도는 만들어줬으면 좋았을텐데</div><div class=post-meta><span title="2022-02-20 23:19:41 +0900 +0900">February 20, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b3%b5%ed%86%b5%ec%a0%90-setup%ea%b3%bc-teardown aria-label="공통점: setUp과 tearDown">공통점: setUp과 tearDown</a></li><li><a href=#%ec%b0%a8%ec%9d%b4%ec%a0%90-%eb%8f%99%ea%b8%b0%eb%83%90-%eb%b9%84%eb%8f%99%ea%b8%b0%eb%83%90 aria-label="차이점: 동기냐 비동기냐">차이점: 동기냐 비동기냐</a><ul><li><a href=#%eb%8f%99%ea%b8%b0-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="동기 테스트">동기 테스트</a></li><li><a href=#%eb%b9%84%eb%8f%99%ea%b8%b0-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="비동기 테스트">비동기 테스트</a></li></ul></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li></ul></div></details></div><div class=post-content><p>원래는 이전 글에서 Combine Scheduler에 대해 좀 더 알아보는 글을 쓰려고 했는데, 방향에 가닥이 잡히질 않아 다른것부터 쓰기로 했다. 뭔고 하니, 바로 Combine 코드를 단위 테스트하는 방법이다. 현재 개발중인 프로젝트에서는 많은 코드를 Combine 기반으로 작성하고 있기 때문에 테스트 코드 역시 Combine에 맞춰서 구현하게 된다. 그렇다면 어떻게 Combine 코드를 테스트할 수 있을까? 공통점 하나와 차이점 하나로 설명해보겠다.</p><h2 id=공통점-setup과-teardown>공통점: setUp과 tearDown<a hidden class=anchor aria-hidden=true href=#공통점-setup과-teardown>#</a></h2><p>Combine 테스트라면 당연하게도 Publisher를 구독하고 값을 받거나 종료 이벤트를 받는 시점에 받은 값을 검증해야 할 것이다. 그렇다면 결과적으로 Publisher를 구독했을 때 반환되는 Cancellable에 대한 처리가 필요하다는 것이다. 만약 이런 부분을 간과한다면, 어딘가에서부터 이유를 알 수 없이 깨지는 테스트 케이스가 발생하게 될 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>XCTest</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Combine</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CombineTest</span>: XCTestCase {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 초기화</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> subscriptions = Set&lt;AnyCancellable&gt;()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tearDown</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 종료된 테스트 케이스의 Cancellable에 대해 초기화 처리</span>
</span></span><span style=display:flex><span>        subscriptions = []
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=차이점-동기냐-비동기냐>차이점: 동기냐 비동기냐<a hidden class=anchor aria-hidden=true href=#차이점-동기냐-비동기냐>#</a></h2><p>사실 Combine이나 XCTest 프레임워크 상에서 별도로 Combine만을 위한 테스트 도구를 제공하지는 않는다. 예를 들어, RxSwift에는 <a href=https://github.com/ReactiveX/RxSwift/blob/main/RxTest/Schedulers/TestScheduler.swift><code>TestScheduler</code></a>가 있어 가상으로 이벤트의 시간을 조정할 수 있다. 그렇기 때문에 특히나 비동기로 이루어지는 작업에 대한 테스트에 대한 기대값을 조정하기에 편하다. 하지만 Combine에는 그런게 없다. 기존에 제공하는 도구로도 충분히 모든 것을 테스트할 수 있다는 자신감이 아닌가 싶다(물론 실제로도 기존 도구로 모든 테스트가 가능).</p><h3 id=동기-테스트>동기 테스트<a hidden class=anchor aria-hidden=true href=#동기-테스트>#</a></h3><p>동기적인 동작에 대한 테스트는 간단하다. 간략하게 순서로 얘기하자면 다음과 같다.</p><ol><li>테스트할 결과값을 받아와 저장하는 변수와 테스트하고자 하는 성공/실패 기대값을 준비한다.</li><li>테스트하고자 하는 Publisher를 준비한다.</li><li>Publisher를 구독하고 값을 받는 클로져(receiveValue or receiveCompletion)에서 결과값을 저장하는 변수에 값을 저장한다.</li><li>테스트하고자 하는 기대값과 비교한다.</li></ol><p>만약 생성자를 통해 주어진 인자를 소문자화하는 커스텀 Publisher인 LowerCased가 있다고 하자. 그렇다면 이 Publisher에 대해서는 어떻게 테스트해야할까? 다음 코드가 아마 힌트가 될 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// Publisher.LowerCased&lt;String, Never&gt;가 제대로 주어진 값을 소문자화하는지 테스트</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>test_lowerCased</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1 - 결과값을 저장할 변수와 기대값 변수 선언</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> result: String = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expect: String = <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2 - 테스트할 Publisher</span>
</span></span><span style=display:flex><span>    Publisher.LowerCased(<span style=color:#e6db74>&#34;FOO&#34;</span>)
</span></span><span style=display:flex><span>        .sink(receiveValue: {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 3 - 결과값 저장</span>
</span></span><span style=display:flex><span>            result = $0
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .store(<span style=color:#66d9ef>in</span>: &amp;subscriptions)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4 - 결과 검증</span>
</span></span><span style=display:flex><span>    XCTAssertEqual(result, expect)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위에서 얘기한 순서에 해당하는 부분에 주석으로 숫자를 남겨놨다. 이 테스트케이스의 경우 모든 것이 동기적으로 동작할 것이라는 것이 기대되기 때문에 결과값을 클로져 내부에서 받아온다고 하더라도 신경쓸 필요가 없다. 그저 순차적으로 동작할 것을 기대하고 테스트 코드를 작성하면 되는 것이다.</p><p>그렇다면 만약 ViewModel과 같은 역할을 하는 클래스를 테스트한다면 어떻게 해야할까? 이 경우에도 크게 다르지 않다. 아래와 같은 클래스가 있다고 생각해보자. 아래 클래스는 문자열을 입력하면 lowerCased 변수에 입력한 문자열을 소문자로 변환해 저장하는 클래스이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LowerCaseViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>    @Published <span style=color:#66d9ef>private</span>(<span style=color:#66d9ef>set</span>) <span style=color:#66d9ef>var</span> lowerCased: String = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setValue</span>(<span style=color:#66d9ef>_</span> text: String) {
</span></span><span style=display:flex><span>        lowerCased = text.lowerCased()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 경우 다음과 같은 테스트가 가능할 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LowerCaseViewModelTest</span>: XCTestCase {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> viewModel: LowerCaseViewModel!
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> subscriptions = Set&lt;AnyCancellable&gt;()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setUp</span>() {
</span></span><span style=display:flex><span>        viewModel = LowerCaseViewModel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tearDown</span>() {
</span></span><span style=display:flex><span>        subscriptions = []
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>test_lowerCased</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> result: String = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> expected: String = <span style=color:#e6db74>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        viewModel.<span style=color:#960050;background-color:#1e0010>$</span>lowerCased
</span></span><span style=display:flex><span>            .sink(receiveValue: { 
</span></span><span style=display:flex><span>                result = $0
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .store(<span style=color:#66d9ef>in</span>: &amp;subscriptions)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        viewModel.setValue(<span style=color:#e6db74>&#34;FOO&#34;</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        XCTAssertEqual(result, expected)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>viewModel.$lowerCased는 실제로는 ["", &ldquo;foo&rdquo;]의 두 개 값이 방출되고, 딱히 종결이벤트가 발생하지 않지만 해당 테스트 케이스는 동기적 이벤트 발생에 대한 흐름을 쫓고 있기 때문에 결과값이 기대값인 &ldquo;foo"와 동일하기 때문에 의도한대로 성공하는 테스트 케이스가 되는 것이다.</p><p>그렇다면 이번엔 Combine의 비동기 동작은 어떻게 테스트할 수 있는지 알아보자.</p><h3 id=비동기-테스트>비동기 테스트<a hidden class=anchor aria-hidden=true href=#비동기-테스트>#</a></h3><p>위의 동기 동작에 대한 테스트 코드를 보면 사실 일반적인 테스트 코드를 작성하는 것과 그렇게까지 큰 차이가 없다는 것을 알 수 있다. 그렇다면 비동기 동작에 대한 테스트는? 그렇다. 흔히 활용하는 completionHandler에 대한 테스트와 비슷하게 처리할 수 있다. 바로 <a href=https://developer.apple.com/documentation/xctest/xctestexpectation><code>XCTestExpectation</code></a>을 사용하는 것이다. 그 전에, 일단 아래와 같은 ViewModel 클래스가 있다고 가정해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FooViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> fetcher = BarFetcher()
</span></span><span style=display:flex><span>    @Publisher <span style=color:#66d9ef>private</span>(<span style=color:#66d9ef>set</span>) <span style=color:#66d9ef>var</span> fetchedData: String = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#66d9ef>for</span> keyword: String) {
</span></span><span style=display:flex><span>        fetcher.fetchAsync(<span style=color:#66d9ef>for</span>: keyword)
</span></span><span style=display:flex><span>            .assign(to: <span style=color:#f92672>&amp;</span><span style=color:#960050;background-color:#1e0010>$</span>fetchedData)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>어떤 키워드를 입력하면 어딘가로부터 키워드에 맞는 데이터를 가져와 fetchedData에 해당 데이터를 넣어주느 동작을 하는 ViewModel이다. 이 경우에는 키워드에 맞는 데이터를 비동기적으로 가져오는 동작밖에 할 수 없기 때문에 위의 동기 테스트 코드로는 처리할 수 없다. 하지만 이를 위해 위에서 언급한 XCTestExpectation이 존재하는 것이다. 간략한 사용방법은 아래 코드로 알 수 있으나, 자세하게 알고 싶다면 애플 개발자 문서를 찾아보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>test_fetchAsync</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> result = [String]()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expected = [<span style=color:#e6db74>&#34;some text data for keyword&#34;</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 비동기 작업에 대해 대기하도록 하는 XCTestExpectation 생성</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expectation = <span style=color:#66d9ef>self</span>.expectation(description: <span style=color:#66d9ef>#function</span>)
</span></span><span style=display:flex><span>    viewModel.<span style=color:#960050;background-color:#1e0010>$</span>fetchedData
</span></span><span style=display:flex><span>        .dropFirst()
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>prefix</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        .sink(
</span></span><span style=display:flex><span>            receiveCompletion: { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 이벤트 종료와 함께 expectation에 대기 종료할 것을 알린다</span>
</span></span><span style=display:flex><span>                expectation.fulfill() 
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            receiveValue: { 
</span></span><span style=display:flex><span>                result.append($0)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .store(<span style=color:#66d9ef>in</span>: &amp;subscriptions)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    viewModel.fetch(<span style=color:#66d9ef>for</span>: <span style=color:#e6db74>&#34;keyword&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// XCTestExpectation의 종료 메시지를 대기하도록 하는 명령. 최대 5초간 기다리도록 지정.</span>
</span></span><span style=display:flex><span>    waitForExpectations(timeout: <span style=color:#ae81ff>5</span>, handler: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    XCTAssertEqual(result, expected)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>XCTestExpectation의 사용법은 주석으로 대강 알아볼 수 있을 것이다. 여기서 확인해야하는 것은 viewModel.$fetchedData의 뒤에 달라붙어있는 dropFirst()와 prefix(1)이다. 그렇다면 왜 이런 연산자를 사용해야 하는걸까?</p><p>첫번째로 dropFirst를 쓴 이유는 다음과 같다. viewModel.$fetchedData의 경우 초기값이 있는 Publisher다. 이 경우 dropFirst가 없으면 result가 초기값까지 받아 배열에 넣기 때문에 expected 값과 비교하면 테스트 실패라고 나올 것이다. 물론 최종 결과값만 보고 비교해도 상관없다면 기대값과 결과값을 [String]이 아닌 String 타입으로 놓고 비교하면 될 일이다. 하지만 Combine이라는 것은 결국 이벤트 스트림에 대한 것이고, 이에 대해 테스트하기 위해서는 이벤트 스트림 자체에 대한 검증이 필요해지는 것이다(그래서 적절한 TestScheduler가 있으면 더 좋다). 이런 것들은 명시적/암시적으로 환기해가면서 주지하지 않으면 금방 까먹을 수 있기 때문에 개인적으로 위와 같은 패턴을 즐겨 쓰는 편이다.</p><p>두번째로 prefix를 쓴 이유는 다음과 같다. viewModel.$fetchedData는 ViewModel 자체가 deinit되지 않는 한 이벤트 스트림이 종결될 일이 없다. 이벤트 스트림이 종결되지 않는다면 적절한 시점에 expectation.fulfill이 호출되지 않기 때문에 waitForExpectations로 지정한 시간제한에 걸리고 만다. 이런 일을 피하기 위해서는 prefix와 같은 연산자를 통해 이벤트 스트림에 대한 추적을 얼마만큼 할 것인지 지정해야 한다.</p><p>위의 두 연산자를 반드시 써야한다는 것이 아니다. 비동기 동작에 대한 테스트를 할때는 이벤트 스트림에 대한 검증을 해야한다는 것을 잊으면 안된다는 것이다. 특히나 ViewModel과 같은 클래스는 뷰의 상태에 직접적으로 관여하는 경우가 많기 때문에 더더욱 이를 유념해야 한다. 예를 들어 뷰 안에 스위치가 있고, 이 스위치를 전환할때 어떤 비동기 동작을 진행한 후 스위치와 바인딩된 Bool 값이 변경된다고 생각해보자. 비동기 동작을 한 번 진행할때 스위치에 바인딩된 Bool값이 두번 세번 네번 변경된다? 그러면 사용자는 단 한번의 상호작용을 했을 뿐인데 그에 대한 결과를 두번 이상 목격하게 되고, 결과적으로 혼란을 겪게 될 것이다. 이 역시 중요한 버그라고 할 수 있으니 꼭 검증해야 하는 요소라고 할 수 있다.</p><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>오늘은 Combine의 스케쥴러가 아닌 테스트에 대해 알아봤다. 일반적인 테스트 코드 작성법과 크게 다르지 않지만, 어떤 경우에는 단순 값에 대한 검증이 아니라 이벤트 스트림에 대한 검증을 해야한다는 차이가 있었다. 이것만 유념한다면 Combine 코드에 대한 테스트 케이스 작성 및 검증에 큰 어려움을 겪지는 않을 것이다.</p></div><footer class=post-footer></footer><script src=https://utteranc.es/client.js repo=bonoogi/blog-comment issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://bonoogi.github.io/>Hell yeah, World</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>