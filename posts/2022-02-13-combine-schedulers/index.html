<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Swift] Combine의 Scheduler 전환에 대해 알아보기 | Hell yeah, World</title><meta name=keywords content="swift,combine"><meta name=description content="Customize handling of asynchronous events by combining event-processing operators. Swift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리"><meta name=author content="구구리"><link rel=canonical href=https://bonoogi.github.io/posts/2022-02-13-combine-schedulers/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bonoogi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bonoogi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bonoogi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bonoogi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bonoogi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=naver-site-verification content="a7ed1273d644f391578cacca05f27cac326d7530"><script async src="https://www.googletagmanager.com/gtag/js?id=G-DKVGJN68MW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DKVGJN68MW",{anonymize_ip:!1})}</script><meta property="og:title" content="[Swift] Combine의 Scheduler 전환에 대해 알아보기"><meta property="og:description" content="Customize handling of asynchronous events by combining event-processing operators. Swift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리"><meta property="og:type" content="article"><meta property="og:url" content="https://bonoogi.github.io/posts/2022-02-13-combine-schedulers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-13T23:39:13+09:00"><meta property="article:modified_time" content="2022-02-13T23:39:13+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Swift] Combine의 Scheduler 전환에 대해 알아보기"><meta name=twitter:description content="Customize handling of asynchronous events by combining event-processing operators. Swift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bonoogi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Swift] Combine의 Scheduler 전환에 대해 알아보기","item":"https://bonoogi.github.io/posts/2022-02-13-combine-schedulers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Swift] Combine의 Scheduler 전환에 대해 알아보기","name":"[Swift] Combine의 Scheduler 전환에 대해 알아보기","description":"Customize handling of asynchronous events by combining event-processing operators. Swift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리","keywords":["swift","combine"],"articleBody":" Customize handling of asynchronous events by combining event-processing operators.\nSwift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리를 거의 완전히 대체할 수 있다(애시당초 대체하라고 나왔다고 볼 수 있다). Combine이나 Reacive Extension과 같은 형태를 일반적으로 Reactive 혹은 반응형 프로그래밍이라고 부른다. 이게 명칭때문에 React나 반응형 웹 디자인과 개념을 헷갈려하는 사람이 종종 보이는데, 전혀 다른 개념이다.\n여튼 이런 반응형 프로그래밍의 장점이자 특징이라고 한다면 바로 연산자 호출을 통한 작업 스레드 전환이다. 그리고 이 특징이 비동기 작업을 용이하게 만들어주는 것이기도 하고. 그렇다면 Combine 프레임워크에서는 어떻게 스케쥴러를 통해 스레드 전환을 할 수 있는지, 그리고 스케쥴러를 활용한 다른 기능은 뭐가 있는지 알아보자.\nNOTE\n참고로 스케쥴러와 스레드는 서로 다른 객체이다. 간단히 설명하자면, 스케쥴러가 구현된 세부사항에 따라 적절한 스레드를 사용하도록 지시하는 것과 비슷하다. 실제로 자세히 들어가면스케쥴러의 구현체 각각이 스레드를 어떤 식으로 사용하는지가 다 다르다.\nsubscribe(on:)과 receive(on:) subscribe(on:)과 receive(on:)은 위에서 언급한 스케쥴러를 통한 스레드 전환을 수행하는 연산자다. 둘의 동작 차이는 메서드명을 간단하게 문장으로 풀이해서 번역해보면 느낌이 올 것이다.\nsubscribe(on scheduler: S) \u003e subscribe on scheduler S \u003e 스케쥴러 S에서 구독 receive(on scheduler: S) \u003e receive on scheduler S \u003e 스케쥴러 S에서 수신(혹은 수령?) 어떤가 느낌이 좀 오는가? 여기서 Combine Scheduler 프로토콜의 정의인 ‘클로져를 언제 어떻게 실행할지 정의하는 프로토콜’을 생각하면, subscribe(on:)은 구독하려는 클로져에 대해 스케쥴러를 지정하는 것이고, receive(on:)은 수신하는 클로져에 대해 스케쥴러를 지정하는 것이라고 볼 수 있다. 물론 이것만으로는 아직 이해가 어려울 수 있다. 그렇다면 쉬운것부터 생각해보자.\n수신하는 클로져란 무엇일까? Combine은 데이터 그 자체보다는 데이터의 흐름을 다루는 프레임워크다. 이런 관점에서 수신하는 클로져란 무엇일지 생각해보면, 데이터의 흐름을 받아 뭔가 조작을 가하거나 하는 클로져를 말한다는 것을 알수 있다. 예를 들어, .map(_:)과 같은 연산자를 생각해보자. 이 친구의 경우에는 클로져를 인자로 받아 그 클로져에서 데이터 흐름을 통해 흘러들어온 데이터에 조작을 가한후 다음 흐름으로 보내주는 역할을 한다. 그렇다. 이 .map(_:) 메서드가 받은 클로져가 바로 수신하는 클로져다. 고로 receive(on:) 은 이런 map과 같은 메서드에 인자로 넘어가는 클로져를 언제/어떻게 실행할지 정의해놓은 스케쥴러를 지정하는 거라고 볼 수 있다.\n그렇다면 구독하는 클로져란 무엇인가? 구독이 발생하는 지점의 클로져를 말한다. 예를 들면 다음과 같다.\nfunc doSubscribe() { // Closure 0 SomePublisher() .handleEvents(receiveSubscription: { _ in // Closure 1 // 여기서 스레드를 체크하면 Closure 0과 동일한 스레드가 나온다. }) .sink(/* ... */) } doSubscribe 함수에서 SomePublisher를 구독하고 있다. 이때 이 구독하는 이벤트가 발생하는 doSubscribe의 몸체 클로져가 바로 이 구독하는 클로져이다. 이 때 doSubscribe가 메인 스레드에서 수행된다면 구독 역시 메인 스레드에서 수행된다. 하지만 아래처럼 별도의 subscribe(on:) 을 호출해 global 큐를 사용하도록 한다면?\nfunc doSubscribe() { // Closure 0 SomePublisher() .subscribe(on: DispatchQueue.global()) .handleEvents(receiveSubscription: { _ in // Closure 1 // doSubscribe가 어느 스레드에서 수행되었는지는 몰라도 적어도 여기서는 백그라운드 스레드에서 수행된다. }) .sink(/* ... */) } doSubscribe가 어느 스레드에서 수행되었는지와 상관없이, 구독 이벤트가 발생하는 시점의 스레드는 DispatchQueue.global() 에 의해 수행 시점의 적절한 백그라운드 스레드로 전환되는 것이다.\n참고할 것은 subscribe(on:)은 업스트림에 영향을 미치기 때문에 2회 이상 호출되었을 경우 근원이 되는 업스트림에 가까운 메서드에 인자로 넘김 스케쥴러의 명령을 따르게 된다.\n그렇다면 이 인자로 넘기는 스케쥴러는 무엇이고 또 어떤게 있으며, 어떤 상황에 어떤 스케쥴러를 사용해야 하는걸까? 이에 대해서는 좀 더 정리해서 다음 포스팅에서 얘기해보도록 하겠다(언젠간…).\n","wordCount":"1608","inLanguage":"en","datePublished":"2022-02-13T23:39:13+09:00","dateModified":"2022-02-13T23:39:13+09:00","author":{"@type":"Person","name":"구구리"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bonoogi.github.io/posts/2022-02-13-combine-schedulers/"},"publisher":{"@type":"Organization","name":"Hell yeah, World","logo":{"@type":"ImageObject","url":"https://bonoogi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bonoogi.github.io/ accesskey=h title="Hell yeah, World (Alt + H)">Hell yeah, World</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[Swift] Combine의 Scheduler 전환에 대해 알아보기</h1><div class=post-meta><span title='2022-02-13 23:39:13 +0900 +0900'>February 13, 2022</span>&nbsp;·&nbsp;구구리</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#subscribeon%ea%b3%bc-receiveon aria-label="subscribe(on:)과 receive(on:)"><code>subscribe(on:)</code>과 <code>receive(on:)</code></a></li></ul></div></details></div><div class=post-content><blockquote><p>Customize handling of asynchronous events by combining event-processing operators.</p></blockquote><p>Swift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리를 거의 완전히 대체할 수 있다(애시당초 대체하라고 나왔다고 볼 수 있다). Combine이나 Reacive Extension과 같은 형태를 일반적으로 <strong>Reactive</strong> 혹은 <strong>반응형</strong> 프로그래밍이라고 부른다. 이게 명칭때문에 React나 반응형 웹 디자인과 개념을 헷갈려하는 사람이 종종 보이는데, 전혀 다른 개념이다.</p><p>여튼 이런 반응형 프로그래밍의 장점이자 특징이라고 한다면 바로 연산자 호출을 통한 작업 스레드 전환이다. 그리고 이 특징이 비동기 작업을 용이하게 만들어주는 것이기도 하고. 그렇다면 Combine 프레임워크에서는 어떻게 스케쥴러를 통해 스레드 전환을 할 수 있는지, 그리고 스케쥴러를 활용한 다른 기능은 뭐가 있는지 알아보자.</p><hr><p><strong>NOTE</strong></p><p>참고로 스케쥴러와 스레드는 서로 다른 객체이다. 간단히 설명하자면, 스케쥴러가 구현된 세부사항에 따라 적절한 스레드를 사용하도록 지시하는 것과 비슷하다. 실제로 자세히 들어가면스케쥴러의 구현체 각각이 스레드를 어떤 식으로 사용하는지가 다 다르다.</p><hr><h2 id=subscribeon과-receiveon><code>subscribe(on:)</code>과 <code>receive(on:)</code><a hidden class=anchor aria-hidden=true href=#subscribeon과-receiveon>#</a></h2><p><code>subscribe(on:)</code>과 <code>receive(on:)</code>은 위에서 언급한 스케쥴러를 통한 스레드 전환을 수행하는 연산자다. 둘의 동작 차이는 메서드명을 간단하게 문장으로 풀이해서 번역해보면 느낌이 올 것이다.</p><ul><li><code>subscribe(on scheduler: S)</code> > subscribe on scheduler S > 스케쥴러 S에서 구독</li><li><code>receive(on scheduler: S)</code> > receive on scheduler S > 스케쥴러 S에서 수신(혹은 수령?)</li></ul><p>어떤가 느낌이 좀 오는가? 여기서 Combine Scheduler 프로토콜의 정의인 &lsquo;클로져를 언제 어떻게 실행할지 정의하는 프로토콜&rsquo;을 생각하면, <code>subscribe(on:)</code>은 구독하려는 클로져에 대해 스케쥴러를 지정하는 것이고, <code>receive(on:)</code>은 수신하는 클로져에 대해 스케쥴러를 지정하는 것이라고 볼 수 있다. 물론 이것만으로는 아직 이해가 어려울 수 있다. 그렇다면 쉬운것부터 생각해보자.</p><p><strong>수신하는 클로져</strong>란 무엇일까? Combine은 데이터 그 자체보다는 데이터의 흐름을 다루는 프레임워크다. 이런 관점에서 수신하는 클로져란 무엇일지 생각해보면, 데이터의 흐름을 받아 뭔가 조작을 가하거나 하는 클로져를 말한다는 것을 알수 있다. 예를 들어, <code>.map(_:)</code>과 같은 연산자를 생각해보자. 이 친구의 경우에는 클로져를 인자로 받아 그 클로져에서 데이터 흐름을 통해 흘러들어온 데이터에 조작을 가한후 다음 흐름으로 보내주는 역할을 한다. 그렇다. 이 <code>.map(_:)</code> 메서드가 받은 클로져가 바로 수신하는 클로져다. 고로 <code>receive(on:)</code> 은 이런 <code>map</code>과 같은 메서드에 인자로 넘어가는 클로져를 언제/어떻게 실행할지 정의해놓은 스케쥴러를 지정하는 거라고 볼 수 있다.</p><p>그렇다면 <strong>구독하는 클로져</strong>란 무엇인가? 구독이 발생하는 지점의 클로져를 말한다. 예를 들면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doSubscribe</span>() { <span style=color:#75715e>// Closure 0</span>
</span></span><span style=display:flex><span>    SomePublisher()
</span></span><span style=display:flex><span>        .handleEvents(receiveSubscription: { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> <span style=color:#75715e>// Closure 1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 여기서 스레드를 체크하면 Closure 0과 동일한 스레드가 나온다.</span>
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sink(<span style=color:#75715e>/* ... */</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>doSubscribe</code> 함수에서 <code>SomePublisher</code>를 구독하고 있다. 이때 이 구독하는 이벤트가 발생하는 <code>doSubscribe</code>의 몸체 클로져가 바로 이 구독하는 클로져이다. 이 때 <code>doSubscribe</code>가 메인 스레드에서 수행된다면 구독 역시 메인 스레드에서 수행된다. 하지만 아래처럼 별도의 <code>subscribe(on:)</code> 을 호출해 global 큐를 사용하도록 한다면?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doSubscribe</span>() { <span style=color:#75715e>// Closure 0</span>
</span></span><span style=display:flex><span>    SomePublisher()
</span></span><span style=display:flex><span>        .subscribe(on: DispatchQueue.global())
</span></span><span style=display:flex><span>        .handleEvents(receiveSubscription: { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> <span style=color:#75715e>// Closure 1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// doSubscribe가 어느 스레드에서 수행되었는지는 몰라도 적어도 여기서는 백그라운드 스레드에서 수행된다.</span>
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sink(<span style=color:#75715e>/* ... */</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>doSubscribe</code>가 어느 스레드에서 수행되었는지와 상관없이, 구독 이벤트가 발생하는 시점의 스레드는 <code>DispatchQueue.global()</code> 에 의해 수행 시점의 적절한 백그라운드 스레드로 전환되는 것이다.</p><p>참고할 것은 <code>subscribe(on:)</code>은 업스트림에 영향을 미치기 때문에 2회 이상 호출되었을 경우 근원이 되는 업스트림에 가까운 메서드에 인자로 넘김 스케쥴러의 명령을 따르게 된다.</p><p>그렇다면 이 인자로 넘기는 스케쥴러는 무엇이고 또 어떤게 있으며, 어떤 상황에 어떤 스케쥴러를 사용해야 하는걸까? 이에 대해서는 좀 더 정리해서 다음 포스팅에서 얘기해보도록 하겠다(언젠간&mldr;).</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bonoogi.github.io/tags/swift/>swift</a></li><li><a href=https://bonoogi.github.io/tags/combine/>combine</a></li></ul></footer><script src=https://utteranc.es/client.js repo=bonoogi/blog-comment issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://bonoogi.github.io/>Hell yeah, World</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>