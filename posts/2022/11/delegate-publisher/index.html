<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UIKit의 Delegate 패턴에 Combine으로 대응하기 | Hell yeah, World</title><meta name=keywords content="iOS,Swift,UIKit,Combine,Delegate,RxSwift,RxCocoa"><meta name=description content="근데 솔직히 클래스 내에서 걍 Delegate 구현하는게 낫지 않을까?"><meta name=author content="구구리"><link rel=canonical href=https://bonoogi.github.io/posts/2022/11/delegate-publisher/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bonoogi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bonoogi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bonoogi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bonoogi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bonoogi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=naver-site-verification content="a7ed1273d644f391578cacca05f27cac326d7530"><script async src="https://www.googletagmanager.com/gtag/js?id=G-DKVGJN68MW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DKVGJN68MW",{anonymize_ip:!1})}</script><meta property="og:title" content="UIKit의 Delegate 패턴에 Combine으로 대응하기"><meta property="og:description" content="근데 솔직히 클래스 내에서 걍 Delegate 구현하는게 낫지 않을까?"><meta property="og:type" content="article"><meta property="og:url" content="https://bonoogi.github.io/posts/2022/11/delegate-publisher/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-20T16:48:29+09:00"><meta property="article:modified_time" content="2022-11-20T16:48:29+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="UIKit의 Delegate 패턴에 Combine으로 대응하기"><meta name=twitter:description content="근데 솔직히 클래스 내에서 걍 Delegate 구현하는게 낫지 않을까?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bonoogi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"UIKit의 Delegate 패턴에 Combine으로 대응하기","item":"https://bonoogi.github.io/posts/2022/11/delegate-publisher/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UIKit의 Delegate 패턴에 Combine으로 대응하기","name":"UIKit의 Delegate 패턴에 Combine으로 대응하기","description":"근데 솔직히 클래스 내에서 걍 Delegate 구현하는게 낫지 않을까?","keywords":["iOS","Swift","UIKit","Combine","Delegate","RxSwift","RxCocoa"],"articleBody":"Reactive Programming의 대명사 그 자체인 Reactive Extension(이하 Rx), 그리고 그 중에서도 Apple 생태계 개발자를 위한 Rx 구현인 RxSwift, 그 중에서도 UIKit을 위한 구현인 RxCocoa를 보면 각종 UIKit의 Delegate 패턴에 대응하는 Observable을 제공하고 있다. Rx를 처음 접한 그 당시에는 ‘와 씻 완전 신세계다!’ 싶어 거의 모든 코드를 Rx 기반으로 작성했었는데, 그래서 Delegate 패턴에 대한 구현도 Rx를 많이 썼던 기억이 난다. 지금은 걍 Delegate를 직접 구현하는 것을 좀 더 선호하는 편이지만…\n어쨌든, 최근에 진행하는 프로젝트에서 RxSwift 의존성을 Combine으로 이전하는 작업을 했다. 이 때 UIScrollViewDelegate의 scrollViewDidScroll(_ scrollView: UIScrollView) 메서드가 호출될 때의 동작을 Combine으로 처리할 수 있도록 하는 작업도 같이 진행했는데, 이 처리에 대해서 좀 알아보도록 하자.\n일단 세 가지의 타입이 필요하다. Publisher 프로토콜을 구현하는 타입과 Subscription 프로토콜을 구현하는 타입(각 프로토콜이 무슨 역할을 하는지는 문서를 통해 알아보도록 하자). 그리고 UIScrollViewDelegate의 호출되는 메서드가 무엇인지 알려주기 위한 열거형 타입.\n그리고 UIScrollViewDelegate에 대한 구현이기 때문에 UIScrollView에 대한 확장으로 선언하는게 써먹기 편할거라 생각했다. 그러니 결국 다음의 세 타입을 만들게 될 것이다.\nUIScrollView.DelegateEvent(이하 DelegateEvent): UIScrollViewDelegate의 메서드가 호출될 때 호출될 메서드와 인자를 전달해줄 타입. 간단하게 enum으로 구현할 예정이다. UIScrollView.DelegateSubscription(이하 DelegateSubscription): 구독시 구독자에게 이벤트를 전달해줄 타입으로(자세한 것을 애플의 Combine.Subscription 문서를 확인), 실제로 UIScrollViewDelegate를 구현하는 타입이 될것이다. UIScrollView.DelegatePublisher(이하 DelegatePublisher): 이벤트를 전달해줄 게시자 타입. 이 역시 애플의 Combine.Publisher 문서를 확인하자. 위 세가지 타입을 기능만 하도록 구현하면 다음과 같을 것이다. 기본 구현 자체에 대해서는 따로 설명하진 않겠다. Subscription과 Publisher 구현의 경우 SwiftBySundell의 Building custom Combine publishers in Swift을 참고하였으니 해당 아티클을 체크하길 바란다.\nenum DelegateEvent { /// `scrollViewDidScroll(_ scrollView: UIScrollView)` 에 대응하는 케이스 case didScroll(UIScrollView) } class DelegateSubscription: NSObject, UIScrollViewDelegate, Subscription where S.Input == DelegateEvent, S.Failure == Never { private var subscriber: S? init(subscriber: S) { self.subscriber = subscriber } func request(_ demand: Subscribers.Demand) { /* Do Nothing */ } func cancel() { subscriber = nil } // UIScrollViewDelegate 구현 func scrollViewDidScroll(_ scrollView: UIScrollView) { _ = subscriber?.receive(.didScroll(scrollView)) } } struct DelegatePublisher: Publisher { typealias Output = DelegateEvent typealias Failure = Never private let scrollView: UIScrollView init(scrollView: UIScrollView) { self.scrollView = scrollView } func receive(subscriber: S) where S: Subscriber, Never == S.Failure, DelegateEvent == S.Input { let subscription = DelegateSubscription(subscriber: subscriber) subscriber.receive(subscription: subscription) scrollView.delegate = subscription } } 위와 같이 구현하고 UIScrollView의 확장에 계산 프로퍼티로 delegatePublisher를 만들어주면 사용할 수 있다.\nextension UIScrollView { var delegatePublisher: DelegatePublisher { return DelegatePublisher(scrollView: self) } } let scrollView = UIScrollView() let cancellable = scrollView .delegatePublisher .sink { event in switch event { case .didScroll(let scrollView): // Do Something With `scrollView` } } 제법 간단하다. 하지만 이 때 문제가 하나 있다. UIScrollView.delegate는 UIView에 UIGestureRecognizer를 등록하듯이 여러 인스턴스를 추가할 수 있는게 아니고, 한 번에 하나의 delegate만 할당할 수 있기 때문. 그렇기 때문에 아래와 같은 코드에서는 두 번째 delegatePublsher를 호출할 때 첫번째로 호출한 delegatePublisher는 scrollView의 delegate가 아니게 된다.\nvar first = scrollView.delegatePublisher.sink { _ in print(\"Useless!\") } var second = scrollView.delegatePublisher.sink { _ in print(\"Only Works!\") } // 아래와 같이 해결할 수는 있지만 매번 사용할 때마다 `share()`로 // 별도 인스턴스를 만들어줘야 하기 때문에 실수하기에 너무 좋은 코드이다. let sharedDelegatePublisher = scrollView.delegatePublisher.share() first = sharedDelegatePublisher.sink { _ in print(\"It Works!\") } second = sharedDelegatePublisher.sink { _ in print(\"It Works, Too!\") } 그렇다면 어떻게 해야 delegatePublisher를 여러번 호출해도 계속 써먹을 수 있을까? 이를 위해서는 두 가지 조건을 만족해야 한다.\nUIScrollView.delegatePublisher가 UIScrollView 인스턴스 하나당 하나만 생성되어야 한다. 매번 새로 생성하면 이전에 생성한 Publisher에 대한 Subscription은 의미가 없어지니까. 위에서 생긴 하나의 DelegatePublisher를 여러 Subscriber가 공유할 수 있어야 한다. Subscriber가 생길때마다 delegate를 할당하면 결국 여전히 최후의 Subscriber만 이벤트를 받을 수 있으니까. 첫번째 조건은 바꿔 말하자면 UIScrollView 인스턴스가 특정되면 거기에 연결된 DelegatePublisher도 특정할 수 있어야 한다는 얘기다. 이에 대해서는 RxSwift가 해결한 방법을 참고했다. 이 친구들은 RxCocoa 내에 DelegateProxyType이라는 타입을 만들어서 별도의 대리자를 만들었고, 이 친구를 UIScrollView 인스턴스에다가 Associated Object로 할당을 하는 식으로 해결하였다. 물론 DelegateProxyType이 Delegate 역할을 하는 것은 아니고, 일종의 연결점이라고 보는게 낫겠지만…(proxy라는 말을 괜히 쓴게 아님)\n두번째 조건은 잘 생각해보면 어디서 본 말이다. 바로 Publishers.Share다. 애플 문서상에서 이 친구의 정의를 보면 아래와 같이 나와있다.\nA publisher that shares the output of an upstream publisher with multiple subscribers.\nUpstream Publisher의 배출을 여러 Subscriber와 공유하는 Publisher. 결국 두번째 조건은 Share를 사용하면 해결된다. 이를 바탕으로 구현하면 다음과 같은 코드가 만들어진다.\nextension UIScrollView { var delegatePublisher: AnyPublisher { /** `ObjectIdentifier`는 `AnyObject` 인스턴스를 받거나 `Any.Type` 형태의 메타타입을 받아서 ID를 생성할 수 있다. 이 경우에는 `UIScrollView` 인스턴스에 유일한 `DelegatePublisher`를 할당하는게 목표이니 메타타입을 통해 ID를 생성한다. 사실 이렇게 안하고 아래처럼 특정 문자열을 만들어서 그에 대한 UnsafeRawPointer를 만들어도 무방할 것 같다. let someStr = \"SomeStr\" let rawPointer = \u0026someStr */ let objectIdentifier = ObjectIdentifier(DelegatePublisher.self) let integerIdentifier = Int(bitPattern: objectIdentifier) let rawPointer = UnsafeRawPointer(bitPatter: integerIdentifier)! if let existingPublisher = objc_getAssociatedObject(self, rawPointer) as? AnyPublisher { return existingPublisher } else { let newPublisher = DelegatePublisher(scrollView: self) // 여러 Subscriber가 하나의 Upstream Publisher를 공유 .share() // 반환되는 타입을 맞추기 위함 .eraseAnyPublisher() /** `.OBJC_ASSOCIATION_RETAIN` policy를 지정하면 UIScrollView가 DelegatePublisher에 대해 강한 참조를 갖게 되는데, `.OBJC_ASSOCIATION_ASSIGN` policy를 사용해 약한 참조를 갖게 하면 일부 케이스에서 잘못된 메모리 참조가 일어나기 때문에 `.OBJC_ASSOCIATION_RETAIN`를 사용해 강한 참조를 만들어주는게 좋다 */ objc_setAssociatedObject(self, rawPointer, publisher, .OBJC_ASSOCIATION_RETAIN) return newPublisher } } } 이렇게 하면 UIScrollView 하나당 유일한 delegatePublisher가 생겨나기 때문에 여러번 구독해도 문제가 생기지 않는다. 물론 꼭 Associated Object를 사용할 필요는 없다. 차라리 약한 참조를 갖는 Dictionary 타입을 따로 만들어서 글로벌 스토어로 쓰는게 통제하기는 더 좋을지도 모르겠다. 근데 역시 그건 좀 귀찮아서…😅\n다만 여전히 아쉬움은 남는다. Publisher가 아닌 형태의 UIScrollViewDelegate와 DelegatePublisher를 함께 사용하고 싶을 수도 있지 않은가. 이 문제도 비교적 간단하게 해결할 수 있다. 아래 코드와 같이 DelegateSubscription에 UIScrollView에 이미 할당된 delegate를 전달하여 약한 참조로 들고 있도록 하고, 모든 UIScrollViewDelegate 메서드를 구현토록 해서 이를 formerDelegate에 전달해주도록 하는 것이다. 물론 delegatePublisher를 먼저 구독한 후 delegate를 새로 할당하면 기대한 대로 움직이지 않겠지만…(이쯤되면 걍 UIScrollView 자체를 subclassing 하는게 나을듯)\nclass DelegateSubscription: NSObject, UIScrollViewDelegate, Subscription where S.Input == DelegateEvent, S.Failure == Never { private weak var originalDelegate: UIScrollViewDelegate? private var subscriber: S? init(with subscriber: S, originalDelegate: UIScrollViewDelegate?) { self.subscriber = subscriber self.originalDelegate = originalDelegate } ... func scrollViewDidScroll(_ scrollView: UIScrollView) { originalDelegate?.scrollViewDidScroll?(scrollView) _ = subscriber?.receive(.didScroll(scrollView)) } // 이하 나머지 UIScrollViewDelegate 메서드 구현(`originalDelegate`에게 이벤트를 전달하기 위함) } 이걸로 나름 간단하게 Combine을 이용해 Delegate 패턴에 대응하는 방법을 알아봤다. 전체 코드는 따로 Github 저장소에 만들어두었으니 한번 참고해보는 것도 좋겠다.\n참고 SwiftBySundell - Building custom Combine publishers in Swift RxCocoa/DelegateProxyType.swift 애플 공식 문서들 Combine.Publisher Combine.Subscription Combine.Publishers.Share objc_getAssociatedObject(_:_:) objc_setAssociatedObject(_:_:_:_:) ObjectIdentifier ","wordCount":"3177","inLanguage":"en","datePublished":"2022-11-20T16:48:29+09:00","dateModified":"2022-11-20T16:48:29+09:00","author":{"@type":"Person","name":"구구리"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bonoogi.github.io/posts/2022/11/delegate-publisher/"},"publisher":{"@type":"Organization","name":"Hell yeah, World","logo":{"@type":"ImageObject","url":"https://bonoogi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bonoogi.github.io/ accesskey=h title="Hell yeah, World (Alt + H)">Hell yeah, World</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>UIKit의 Delegate 패턴에 Combine으로 대응하기</h1><div class=post-description>근데 솔직히 클래스 내에서 걍 Delegate 구현하는게 낫지 않을까?</div><div class=post-meta><span title='2022-11-20 16:48:29 +0900 +0900'>November 20, 2022</span>&nbsp;·&nbsp;구구리</div></header><div class=post-content><p>Reactive Programming의 대명사 그 자체인 Reactive Extension(이하 Rx), 그리고 그 중에서도 Apple 생태계 개발자를 위한 Rx 구현인 <a href=https://github.com/ReactiveX/RxSwift>RxSwift</a>, 그 중에서도 UIKit을 위한 구현인 RxCocoa를 보면 각종 UIKit의 Delegate 패턴에 대응하는 Observable을 제공하고 있다. Rx를 처음 접한 그 당시에는 &lsquo;와 씻 완전 신세계다!&rsquo; 싶어 거의 모든 코드를 Rx 기반으로 작성했었는데, 그래서 Delegate 패턴에 대한 구현도 Rx를 많이 썼던 기억이 난다. 지금은 걍 Delegate를 직접 구현하는 것을 좀 더 선호하는 편이지만&mldr;</p><p>어쨌든, 최근에 진행하는 프로젝트에서 RxSwift 의존성을 Combine으로 이전하는 작업을 했다. 이 때 <code>UIScrollViewDelegate</code>의 <code>scrollViewDidScroll(_ scrollView: UIScrollView)</code> 메서드가 호출될 때의 동작을 Combine으로 처리할 수 있도록 하는 작업도 같이 진행했는데, 이 처리에 대해서 좀 알아보도록 하자.</p><p>일단 세 가지의 타입이 필요하다. <code>Publisher</code> 프로토콜을 구현하는 타입과 <code>Subscription</code> 프로토콜을 구현하는 타입(각 프로토콜이 무슨 역할을 하는지는 문서를 통해 알아보도록 하자). 그리고 <code>UIScrollViewDelegate</code>의 호출되는 메서드가 무엇인지 알려주기 위한 열거형 타입.</p><p>그리고 <code>UIScrollViewDelegate</code>에 대한 구현이기 때문에 <code>UIScrollView</code>에 대한 확장으로 선언하는게 써먹기 편할거라 생각했다. 그러니 결국 다음의 세 타입을 만들게 될 것이다.</p><ul><li><code>UIScrollView.DelegateEvent</code>(이하 <code>DelegateEvent</code>): <code>UIScrollViewDelegate</code>의 메서드가 호출될 때 호출될 메서드와 인자를 전달해줄 타입. 간단하게 <code>enum</code>으로 구현할 예정이다.</li><li><code>UIScrollView.DelegateSubscription</code>(이하 <code>DelegateSubscription</code>): 구독시 구독자에게 이벤트를 전달해줄 타입으로(자세한 것을 애플의 <a href=https://developer.apple.com/documentation/combine/subscription><code>Combine.Subscription</code> 문서</a>를 확인), 실제로 <code>UIScrollViewDelegate</code>를 구현하는 타입이 될것이다.</li><li><code>UIScrollView.DelegatePublisher</code>(이하 <code>DelegatePublisher</code>): 이벤트를 전달해줄 게시자 타입. 이 역시 애플의 <a href=https://developer.apple.com/documentation/combine/publisher><code>Combine.Publisher</code> 문서</a>를 확인하자.</li></ul><p>위 세가지 타입을 기능만 하도록 구현하면 다음과 같을 것이다. 기본 구현 자체에 대해서는 따로 설명하진 않겠다. <code>Subscription</code>과 <code>Publisher</code> 구현의 경우 SwiftBySundell의 <a href=https://www.swiftbysundell.com/articles/building-custom-combine-publishers-in-swift/>Building custom Combine publishers in Swift</a>을 참고하였으니 해당 아티클을 체크하길 바란다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>DelegateEvent</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// `scrollViewDidScroll(_ scrollView: UIScrollView)` 에 대응하는 케이스</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> didScroll(UIScrollView)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DelegateSubscription</span>&lt;S: Subscriber&gt;: NSObject, UIScrollViewDelegate, 
</span></span><span style=display:flex><span>    Subscription <span style=color:#66d9ef>where</span> S.Input == DelegateEvent, S.Failure == Never {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> subscriber: S?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(subscriber: S) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.subscriber = subscriber
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>request</span>(<span style=color:#66d9ef>_</span> demand: Subscribers.Demand) { <span style=color:#75715e>/* Do Nothing */</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>cancel</span>() {
</span></span><span style=display:flex><span>        subscriber = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// UIScrollViewDelegate 구현</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scrollViewDidScroll</span>(<span style=color:#66d9ef>_</span> scrollView: UIScrollView) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>_</span> = subscriber?.receive(.didScroll(scrollView))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DelegatePublisher</span>: Publisher {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typealias</span> Output = DelegateEvent
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typealias</span> Failure = Never
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> scrollView: UIScrollView
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(scrollView: UIScrollView) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.scrollView = scrollView
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>receive</span>&lt;S&gt;(subscriber: S) <span style=color:#66d9ef>where</span> S: Subscriber, Never == S.Failure, DelegateEvent == S.Input {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> subscription = DelegateSubscription(subscriber: subscriber)
</span></span><span style=display:flex><span>        subscriber.receive(subscription: subscription)
</span></span><span style=display:flex><span>        scrollView.delegate = subscription
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위와 같이 구현하고 <code>UIScrollView</code>의 확장에 계산 프로퍼티로 <code>delegatePublisher</code>를 만들어주면 사용할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>UIScrollView</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> delegatePublisher: DelegatePublisher {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> DelegatePublisher(scrollView: <span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> scrollView = UIScrollView() 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> cancellable = scrollView
</span></span><span style=display:flex><span>    .delegatePublisher
</span></span><span style=display:flex><span>    .sink { event <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> event {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> .didScroll(<span style=color:#66d9ef>let</span> scrollView):
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Do Something With `scrollView`</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>제법 간단하다. 하지만 이 때 문제가 하나 있다. <code>UIScrollView.delegate</code>는 <code>UIView</code>에 <code>UIGestureRecognizer</code>를 등록하듯이 여러 인스턴스를 추가할 수 있는게 아니고, 한 번에 하나의 <code>delegate</code>만 할당할 수 있기 때문. 그렇기 때문에 아래와 같은 코드에서는 두 번째 <code>delegatePublsher</code>를 호출할 때 첫번째로 호출한 <code>delegatePublisher</code>는 <code>scrollView</code>의 <code>delegate</code>가 아니게 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> first = scrollView.delegatePublisher.sink { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> print(<span style=color:#e6db74>&#34;Useless!&#34;</span>) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> second = scrollView.delegatePublisher.sink { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> print(<span style=color:#e6db74>&#34;Only Works!&#34;</span>) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 아래와 같이 해결할 수는 있지만 매번 사용할 때마다 `share()`로</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 별도 인스턴스를 만들어줘야 하기 때문에 실수하기에 너무 좋은 코드이다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> sharedDelegatePublisher = scrollView.delegatePublisher.share()
</span></span><span style=display:flex><span>first = sharedDelegatePublisher.sink { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> print(<span style=color:#e6db74>&#34;It Works!&#34;</span>) }
</span></span><span style=display:flex><span>second = sharedDelegatePublisher.sink { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> print(<span style=color:#e6db74>&#34;It Works, Too!&#34;</span>) }
</span></span></code></pre></div><p>그렇다면 어떻게 해야 <code>delegatePublisher</code>를 여러번 호출해도 계속 써먹을 수 있을까? 이를 위해서는 두 가지 조건을 만족해야 한다.</p><ul><li><code>UIScrollView.delegatePublisher</code>가 <code>UIScrollView</code> 인스턴스 하나당 하나만 생성되어야 한다. 매번 새로 생성하면 이전에 생성한 <code>Publisher</code>에 대한 <code>Subscription</code>은 의미가 없어지니까.</li><li>위에서 생긴 하나의 <code>DelegatePublisher</code>를 여러 <code>Subscriber</code>가 공유할 수 있어야 한다. <code>Subscriber</code>가 생길때마다 delegate를 할당하면 결국 여전히 최후의 <code>Subscriber</code>만 이벤트를 받을 수 있으니까.</li></ul><p>첫번째 조건은 바꿔 말하자면 <code>UIScrollView</code> 인스턴스가 특정되면 거기에 연결된 <code>DelegatePublisher</code>도 특정할 수 있어야 한다는 얘기다. 이에 대해서는 RxSwift가 해결한 방법을 참고했다. 이 친구들은 <a href=https://github.com/ReactiveX/RxSwift/blob/main/RxCocoa/Common/DelegateProxyType.swift>RxCocoa 내에 <code>DelegateProxyType</code>이라는 타입</a>을 만들어서 별도의 대리자를 만들었고, 이 친구를 <code>UIScrollView</code> 인스턴스에다가 Associated Object로 할당을 하는 식으로 해결하였다. 물론 <code>DelegateProxyType</code>이 Delegate 역할을 하는 것은 아니고, 일종의 연결점이라고 보는게 낫겠지만&mldr;(proxy라는 말을 괜히 쓴게 아님)</p><p>두번째 조건은 잘 생각해보면 어디서 본 말이다. 바로 <a href=https://developer.apple.com/documentation/combine/publishers/share><code>Publishers.Share</code></a>다. 애플 문서상에서 이 친구의 정의를 보면 아래와 같이 나와있다.</p><blockquote><p>A publisher that shares the output of an upstream publisher with multiple subscribers.</p></blockquote><p>Upstream Publisher의 배출을 여러 Subscriber와 공유하는 Publisher. 결국 두번째 조건은 <code>Share</code>를 사용하면 해결된다. 이를 바탕으로 구현하면 다음과 같은 코드가 만들어진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>UIScrollView</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> delegatePublisher: AnyPublisher&lt;DelegateEvent, Never&gt; {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>        `ObjectIdentifier`는 `AnyObject` 인스턴스를 받거나 `Any.Type` 형태의
</span></span></span><span style=display:flex><span><span style=color:#75715e>        메타타입을 받아서 ID를 생성할 수 있다. 이 경우에는 `UIScrollView` 인스턴스에
</span></span></span><span style=display:flex><span><span style=color:#75715e>        유일한 `DelegatePublisher`를 할당하는게 목표이니 메타타입을 통해 ID를 생성한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        
</span></span></span><span style=display:flex><span><span style=color:#75715e>        사실 이렇게 안하고 아래처럼 특정 문자열을 만들어서 그에 대한 UnsafeRawPointer를 만들어도 무방할 것 같다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        let someStr = &#34;SomeStr&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>        let rawPointer = &amp;someStr
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> objectIdentifier = ObjectIdentifier(DelegatePublisher.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> integerIdentifier = Int(bitPattern: objectIdentifier)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> rawPointer = UnsafeRawPointer(bitPatter: integerIdentifier)<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> existingPublisher = objc_getAssociatedObject(<span style=color:#66d9ef>self</span>, rawPointer) <span style=color:#66d9ef>as</span>? AnyPublisher&lt;DelegateEvent, Never&gt; {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> existingPublisher
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> newPublisher = DelegatePublisher(scrollView: <span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 여러 Subscriber가 하나의 Upstream Publisher를 공유</span>
</span></span><span style=display:flex><span>                .share()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 반환되는 타입을 맞추기 위함</span>
</span></span><span style=display:flex><span>                .eraseAnyPublisher()
</span></span><span style=display:flex><span>            <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>            `.OBJC_ASSOCIATION_RETAIN` policy를 지정하면 UIScrollView가
</span></span></span><span style=display:flex><span><span style=color:#75715e>            DelegatePublisher에 대해 강한 참조를 갖게 되는데, `.OBJC_ASSOCIATION_ASSIGN`
</span></span></span><span style=display:flex><span><span style=color:#75715e>            policy를 사용해 약한 참조를 갖게 하면 일부 케이스에서 잘못된 메모리 참조가 일어나기 때문에
</span></span></span><span style=display:flex><span><span style=color:#75715e>            `.OBJC_ASSOCIATION_RETAIN`를 사용해 강한 참조를 만들어주는게 좋다
</span></span></span><span style=display:flex><span><span style=color:#75715e>             */</span>
</span></span><span style=display:flex><span>            objc_setAssociatedObject(<span style=color:#66d9ef>self</span>, rawPointer, publisher, .OBJC_ASSOCIATION_RETAIN)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> newPublisher
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이렇게 하면 <code>UIScrollView</code> 하나당 유일한 <code>delegatePublisher</code>가 생겨나기 때문에 여러번 구독해도 문제가 생기지 않는다. 물론 꼭 Associated Object를 사용할 필요는 없다. 차라리 약한 참조를 갖는 <code>Dictionary</code> 타입을 따로 만들어서 글로벌 스토어로 쓰는게 통제하기는 더 좋을지도 모르겠다. 근데 역시 그건 좀 귀찮아서&mldr;😅</p><p>다만 여전히 아쉬움은 남는다. <code>Publisher</code>가 아닌 형태의 <code>UIScrollViewDelegate</code>와 <code>DelegatePublisher</code>를 함께 사용하고 싶을 수도 있지 않은가. 이 문제도 비교적 간단하게 해결할 수 있다. 아래 코드와 같이 <code>DelegateSubscription</code>에 <code>UIScrollView</code>에 이미 할당된 <code>delegate</code>를 전달하여 약한 참조로 들고 있도록 하고, 모든 <code>UIScrollViewDelegate</code> 메서드를 구현토록 해서 이를 <code>formerDelegate</code>에 전달해주도록 하는 것이다. 물론 <code>delegatePublisher</code>를 먼저 구독한 후 <code>delegate</code>를 새로 할당하면 기대한 대로 움직이지 않겠지만&mldr;(이쯤되면 걍 <code>UIScrollView</code> 자체를 subclassing 하는게 나을듯)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DelegateSubscription</span>&lt;S: Subscriber&gt;: NSObject, UIScrollViewDelegate, Subscription <span style=color:#66d9ef>where</span> S.Input == DelegateEvent, S.Failure == Never {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>var</span> originalDelegate: UIScrollViewDelegate?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> subscriber: S?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(with subscriber: S, originalDelegate: UIScrollViewDelegate?) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.subscriber = subscriber
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.originalDelegate = originalDelegate
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>scrollViewDidScroll</span>(<span style=color:#66d9ef>_</span> scrollView: UIScrollView) {
</span></span><span style=display:flex><span>        originalDelegate?.scrollViewDidScroll?(scrollView)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>_</span> = subscriber?.receive(.didScroll(scrollView))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 이하 나머지 UIScrollViewDelegate 메서드 구현(`originalDelegate`에게 이벤트를 전달하기 위함)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이걸로 나름 간단하게 Combine을 이용해 Delegate 패턴에 대응하는 방법을 알아봤다. 전체 코드는 <a href=https://github.com/bonoogi/DelegatePublisher>따로 Github 저장소</a>에 만들어두었으니 한번 참고해보는 것도 좋겠다.</p><h3 id=참고>참고<a hidden class=anchor aria-hidden=true href=#참고>#</a></h3><ul><li><a href=https://www.swiftbysundell.com/articles/building-custom-combine-publishers-in-swift/>SwiftBySundell - Building custom Combine publishers in Swift</a></li><li><a href=https://github.com/ReactiveX/RxSwift/blob/main/RxCocoa/Common/DelegateProxyType.swift>RxCocoa/DelegateProxyType.swift</a></li><li>애플 공식 문서들<ul><li><a href=https://developer.apple.com/documentation/combine/publisher><code>Combine.Publisher</code></a></li><li><a href=https://developer.apple.com/documentation/combine/subscription><code>Combine.Subscription</code></a></li><li><a href=https://developer.apple.com/documentation/combine/publishers/share><code>Combine.Publishers.Share</code></a></li><li><a href=https://developer.apple.com/documentation/objectivec/1418865-objc_getassociatedobject><code>objc_getAssociatedObject(_:_:)</code></a></li><li><a href=https://developer.apple.com/documentation/objectivec/1418509-objc_setassociatedobject><code>objc_setAssociatedObject(_:_:_:_:)</code></a></li><li><a href=https://developer.apple.com/documentation/swift/objectidentifier><code>ObjectIdentifier</code></a></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bonoogi.github.io/tags/ios/>iOS</a></li><li><a href=https://bonoogi.github.io/tags/swift/>swift</a></li><li><a href=https://bonoogi.github.io/tags/uikit/>UIKit</a></li><li><a href=https://bonoogi.github.io/tags/combine/>combine</a></li><li><a href=https://bonoogi.github.io/tags/delegate/>Delegate</a></li><li><a href=https://bonoogi.github.io/tags/rxswift/>RxSwift</a></li><li><a href=https://bonoogi.github.io/tags/rxcocoa/>RxCocoa</a></li></ul></footer><script src=https://utteranc.es/client.js repo=bonoogi/blog-comment issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://bonoogi.github.io/>Hell yeah, World</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>