<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Swift] Combine의 Backpressure 처리 | Hell yeah, World</title><meta name=keywords content="swift,combine,backpressure"><meta name=description content="배압이라고 부르는게 좋을까 Backpressure라고 부르는게 좋을까?"><meta name=author content="구구리"><link rel=canonical href=https://bonoogi.github.io/posts/2022/03/01-combine-backpressure/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bonoogi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bonoogi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bonoogi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bonoogi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bonoogi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=naver-site-verification content="a7ed1273d644f391578cacca05f27cac326d7530"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1380985258636942" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DKVGJN68MW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DKVGJN68MW",{anonymize_ip:!1})}</script><meta property="og:title" content="[Swift] Combine의 Backpressure 처리"><meta property="og:description" content="배압이라고 부르는게 좋을까 Backpressure라고 부르는게 좋을까?"><meta property="og:type" content="article"><meta property="og:url" content="https://bonoogi.github.io/posts/2022/03/01-combine-backpressure/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-06T22:57:09+09:00"><meta property="article:modified_time" content="2022-03-06T22:57:09+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Swift] Combine의 Backpressure 처리"><meta name=twitter:description content="배압이라고 부르는게 좋을까 Backpressure라고 부르는게 좋을까?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bonoogi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Swift] Combine의 Backpressure 처리","item":"https://bonoogi.github.io/posts/2022/03/01-combine-backpressure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Swift] Combine의 Backpressure 처리","name":"[Swift] Combine의 Backpressure 처리","description":"배압이라고 부르는게 좋을까 Backpressure라고 부르는게 좋을까?","keywords":["swift","combine","backpressure"],"articleBody":"Combine이든 RxSwift든 리액티브 프로그래밍 프레임워크를 다루다보면 한번씩 마주하게 되는 문제가 몇가지 있다. 하나는 메모리 관리 문제고(보통 이건 초심자가 많이 겪는다), 또 하나는 배압(Backpressure) 문제다. 리액티브 프로그래밍에서 배압이란 무엇을 말하는가? 구독자와 게시자가 있다고 할 때, 구독자가 값(혹은 이벤트)을 소비하는 속도가 게시자가 값을 보내는 속도를 따라가지 못하는 상황을 일컫는다. 이게 원래는 유체동역학 용어(위키백과: Back Pressure)라는데, 프로그래밍 관점에서 리액티브 프로그래밍이라는게 값의 흐름이니 정말 적절한 용어가 아닌가 싶다.\nBy Engr.Nithin Mohandas - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=74922539 여튼 이런 배압 문제는 일반적으로는 쉽게 발생하지 않는다. 일반적으로 리액티브 프로그래밍을 비동기 처리를 위해 사용하다보니 게시자의 값 송출이 감당하지 못할만한 상황이 자주 일어나지 않기 때문이다. 그렇기 때문에 앞에서 초심자가 많이 겪는 메모리 관리 문제보다는 좀 더 리액티브 프로그래밍을 헤비하게 사용하는 경우 맞닥뜨리기 쉽다(앱에서 발생하는 온갖 이벤트를 다 리액티브하게 처리를 한다던가…). 예를 들어 기기의 자이로 센서 등을 통해 값을 계속해서 전달받는 경우가 있다고 하자. (센서의 민감도에 따라 다르겠지만) 1초 사이에 어마어마하게 많은 값을 받게 될 수도 있다. 이런 경우에는 차라리 특정 시간차를 두고 그 사이에 온 최초 혹은 최후 혹은 어떤 하나의 값을 받아도 문제가 없을 것이다.\nReactiveX의 경우에는 throttle이나 debounce, buffer 등의 연산자를 활용하거나 경우에 따라 적절한 Cold/Hot Observable을 사용하라는 식의 지침이 있다(ReactiveX: Back pressure operators).\n그렇다면 Combine의 경우에는 어떤 식으로 처리할 수 있을까? 우선, Combine도 Throttle이나 Debounce, Buffer와 같은 사전정의된 Publisher를 제공한다. 사실 이것들만 잘 활용해도 어지간한 케이스에는 대응할 수 있다.\n하지만 게시자(Publisher)와 구독(Subscription)을 직접 구현하는 방법으로도 배압을 통제할 수 있다. Combine은 구독자(Subscriber)가 게시자로부터 값을 당겨오는 메커니즘을 사용한다. 이때 구독자는 게시자에게 Subscribers.Demand라는 구조체를 전달해 얼만큼의 값을 당겨올지 요청할 수 있다. 그리고 이 Demand를 조절하는 방식으로 값을 당겨오는 것을 통제해 배압 문제를 처리할 수 있는 것이다. 예를 들어 외부에서 Demand를 통제할 수 있는 커스텀 구독자를 만들고, 상황에 따라 이 구독자의 참조를 지닌 상태에서 값의 처리가 힘든 상황이 되면 잠시 값을 당겨오지 않도록 했다가 다시 준비가 되면 당겨올 수 있도록 하는 것이다.\n이 때 주의할 것이 하나 있는데, Demand를 조절하는 방법에는 가산(add)만이 존재한다는 것이다. 예를 들어 이미 .max(5)와 같은 Demand가 동작을 하고 있다면, 3번째 값을 받고 .none을 전달해 더이상 값을 받지 않겠다고 해도 앞선 .max(5)에 따라 4번째, 5번째 값을 받고 나서야 .none이 효력을 발휘한다. 그렇기 때문에 직접적으로 Demand를 조절하고자 하는 경우에는 .max(1)과 같이 한번에 하나씩의 값을 받는 식으로 처리하는게 좀 더 유용할 것이다(무조건 이렇게 하라는 건 아니다!).\n","wordCount":"1296","inLanguage":"en","datePublished":"2022-03-06T22:57:09+09:00","dateModified":"2022-03-06T22:57:09+09:00","author":{"@type":"Person","name":"구구리"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bonoogi.github.io/posts/2022/03/01-combine-backpressure/"},"publisher":{"@type":"Organization","name":"Hell yeah, World","logo":{"@type":"ImageObject","url":"https://bonoogi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bonoogi.github.io/ accesskey=h title="Hell yeah, World (Alt + H)">Hell yeah, World</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[Swift] Combine의 Backpressure 처리</h1><div class=post-description>배압이라고 부르는게 좋을까 Backpressure라고 부르는게 좋을까?</div><div class=post-meta><span title='2022-03-06 22:57:09 +0900 +0900'>March 6, 2022</span>&nbsp;·&nbsp;구구리</div></header><div class=post-content><p>Combine이든 RxSwift든 리액티브 프로그래밍 프레임워크를 다루다보면 한번씩 마주하게 되는 문제가 몇가지 있다. 하나는 메모리 관리 문제고(보통 이건 초심자가 많이 겪는다), 또 하나는 배압(Backpressure) 문제다. 리액티브 프로그래밍에서 배압이란 무엇을 말하는가? 구독자와 게시자가 있다고 할 때, 구독자가 값(혹은 이벤트)을 소비하는 속도가 게시자가 값을 보내는 속도를 따라가지 못하는 상황을 일컫는다. 이게 원래는 유체동역학 용어(위키백과: <a href=https://en.wikipedia.org/wiki/Back_pressure>Back Pressure</a>)라는데, 프로그래밍 관점에서 리액티브 프로그래밍이라는게 값의 흐름이니 정말 적절한 용어가 아닌가 싶다.</p><p><figure><img src=/images/2022-03-06-combine-backpressure/back-pressure.jpg alt="By Engr.Nithin Mohandas - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=74922539"><figcaption>By Engr.Nithin Mohandas - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=74922539</figcaption></figure></p><p>여튼 이런 배압 문제는 일반적으로는 쉽게 발생하지 않는다. 일반적으로 리액티브 프로그래밍을 비동기 처리를 위해 사용하다보니 게시자의 값 송출이 감당하지 못할만한 상황이 자주 일어나지 않기 때문이다. 그렇기 때문에 앞에서 초심자가 많이 겪는 메모리 관리 문제보다는 좀 더 리액티브 프로그래밍을 헤비하게 사용하는 경우 맞닥뜨리기 쉽다(앱에서 발생하는 온갖 이벤트를 다 리액티브하게 처리를 한다던가&mldr;). 예를 들어 기기의 자이로 센서 등을 통해 값을 계속해서 전달받는 경우가 있다고 하자. (센서의 민감도에 따라 다르겠지만) 1초 사이에 어마어마하게 많은 값을 받게 될 수도 있다. 이런 경우에는 차라리 특정 시간차를 두고 그 사이에 온 최초 혹은 최후 혹은 어떤 하나의 값을 받아도 문제가 없을 것이다.</p><hr><p>ReactiveX의 경우에는 throttle이나 debounce, buffer 등의 연산자를 활용하거나 경우에 따라 적절한 Cold/Hot Observable을 사용하라는 식의 지침이 있다(ReactiveX: <a href=https://reactivex.io/documentation/operators/backpressure.html>Back pressure operators</a>).</p><p>그렇다면 Combine의 경우에는 어떤 식으로 처리할 수 있을까? 우선, Combine도 <a href=https://developer.apple.com/documentation/combine/publishers/throttle><code>Throttle</code></a>이나 <a href=https://developer.apple.com/documentation/combine/publishers/debounce><code>Debounce</code></a>, <a href=https://developer.apple.com/documentation/combine/publishers/buffer><code>Buffer</code></a>와 같은 사전정의된 <code>Publisher</code>를 제공한다. 사실 이것들만 잘 활용해도 어지간한 케이스에는 대응할 수 있다.</p><p>하지만 게시자(<code>Publisher</code>)와 구독(<code>Subscription</code>)을 직접 구현하는 방법으로도 배압을 통제할 수 있다. Combine은 구독자(<code>Subscriber</code>)가 게시자로부터 값을 당겨오는 메커니즘을 사용한다. 이때 구독자는 게시자에게 <a href=https://developer.apple.com/documentation/combine/subscribers/demand><code>Subscribers.Demand</code></a>라는 구조체를 전달해 얼만큼의 값을 당겨올지 요청할 수 있다. 그리고 이 <code>Demand</code>를 조절하는 방식으로 값을 당겨오는 것을 통제해 배압 문제를 처리할 수 있는 것이다. 예를 들어 외부에서 <code>Demand</code>를 통제할 수 있는 커스텀 구독자를 만들고, 상황에 따라 이 구독자의 참조를 지닌 상태에서 값의 처리가 힘든 상황이 되면 잠시 값을 당겨오지 않도록 했다가 다시 준비가 되면 당겨올 수 있도록 하는 것이다.</p><p>이 때 주의할 것이 하나 있는데, <code>Demand</code>를 조절하는 방법에는 가산(add)만이 존재한다는 것이다. 예를 들어 이미 <code>.max(5)</code>와 같은 <code>Demand</code>가 동작을 하고 있다면, 3번째 값을 받고 <code>.none</code>을 전달해 더이상 값을 받지 않겠다고 해도 앞선 <code>.max(5)</code>에 따라 4번째, 5번째 값을 받고 나서야 <code>.none</code>이 효력을 발휘한다. 그렇기 때문에 직접적으로 <code>Demand</code>를 조절하고자 하는 경우에는 <code>.max(1)</code>과 같이 한번에 하나씩의 값을 받는 식으로 처리하는게 좀 더 유용할 것이다(무조건 이렇게 하라는 건 아니다!).</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bonoogi.github.io/tags/swift/>swift</a></li><li><a href=https://bonoogi.github.io/tags/combine/>combine</a></li><li><a href=https://bonoogi.github.io/tags/backpressure/>backpressure</a></li></ul></footer><script src=https://utteranc.es/client.js repo=bonoogi/blog-comment issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://bonoogi.github.io/>Hell yeah, World</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>