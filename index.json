[{"content":"애플 플랫폼 앱의 경우, 테스트플라이트를 통해서 테스트 빌드를 배포하는 경우가 많다. 그런데 이게 IPA 파일을 업로드하고 앱스토어커넥트 내부에서 뭔가 조치를 취한 후에 사용이 가능해지기 때문에 업로드 이후에도 몇십분 정도 기다려야 앱을 설치할 수 있게 된다. 몇십분이라고 해봐야 조금만 기다리면 되는 일이긴 하나, 팀의 내부 사정에 따라 업로드한 앱을 바로 설치해서 테스트해보고 싶은 경우가 많기 때문에 테스트플라이트 대신 다른 방법을 쓰는 경우도 꽤 된다. 예를 들면 Firebase App Distribution이나 App Center Distribute를 사용하는 것이다(And so on\u0026hellip;).\n이 방법들은 자기들 서버에 IPA 파일을 올려두고 테스터의 기기에서 해당 파일을 설치하는 방법을 사용하기 때문에 테스트플라이트 배포와 달리 업로드 직후 바로 설치가 가능한데, 문제는 IPA 파일을 생성할 때 사용한 프로필에 등록된 기기에서만 설치할 수 있다는 것이다. 이 경우 코드 변화 없이 새 테스터만 추가해야할 경우 다시 IPA 파일을 생성하기가 매우 번거롭다는 문제가 있다. 물론 변경된 프로필을 받아와 IPA 파일을 다시 서명하면 되지만 처음에는 이 방법을 몰라서 시간을 많이 날려먹었더랬다. 여튼 기본적으로는 아래와 같은 방법으로 서명을 다시 할 수 있다.\nipa 파일 unzip하기(잘 모르겠으면 걍 finder에서 확장자 바꾸고 압축해제하면 됨) 압축해제된 경로로 들어가 해당 앱의 코드 시그니쳐를 삭제한다 (Payload/{YourAppName}.app/_CodeSignature/) 재서명할 프로비져닝 프로필을 앱 경로(Payload/{YourAppName}.app/)에 embedded.mobileprovision 이름으로 붙여넣기 codesign 유틸리티로 서명하기 앱을 다시 압축하기 설명이 다소 불친절하다고 생각할 수 있는데, 다 이유가 있다. 그냥 fastlane의 resign 명령어를 쓰면 되기 때문이다. 위에 설명해둔 것은 resign 명령을 했을떄 뭔 일이 일어나는지 대강이라도 알면 좋을것 같아서\u0026hellip; 여튼 fastlane의 경우 다음과 같이 할 수 있다.\n# Fastfile 내부 lane :some_resign_action do resign( ipa: \u0026#34;재서명할 ipa 파일 경로\u0026#34;, signing_identity: \u0026#34;앱 서명 identity\u0026#34;, provisioning_profile: { \u0026#34;app.bundle.id\u0026#34; =\u0026gt; \u0026#34;재서명할 프로필 경로\u0026#34; } ) end 참고로 앱 서명 identity과 정확히 뭔지 잘 모르겠으면 해당 프로젝트를 xcode에서 열어서 Signing \u0026amp; Capability 탭으로 이동해 Signing Certificate가 뭔지 확인하면 된다. 아니면 아래 커맨드라인 명령을 통해 현재 기기에 존재하는 서명을 찾을 수 있다.\n$ security find-identity -v -p codesigning 근데 또 이제 매번 최신 프로필을 받아와서 경로를 입력하고 어쩌고 저쩌고 하기가 귀찮을 수 있다. 그런 경우에는 match 설정을 미리 해두면 좀 더 간편하게 처리할 수 있다. match 명령어를 실행할 때 아래와 같이 사전에 설정한 경로에 프로필을 저장하도록 하는 것이다.\n# Fastfile 내부 lane :some_match_action do match( readonly: true, type: \u0026#34;development\u0026#34; # 이 외에도 adhoc, release 등... app_identifier: \u0026#34;app.bundle.id\u0026#34;, output_path: \u0026#34;다운받을 경로\u0026#34; ) end 이런식이면 지정된 경로에 프로비져닝 프로필이 다운로드된다. 그럼 이 명령어와 저 위의 resign 명령어를 조합해 항상 새롭게 갱신된 프로필로 재서명할 수 있다.\n# Fastfile 내부 lane: :resign do |options| ipa_path = options.fetch(:ipa_path, \u0026#34;\u0026#34;) # ipa_path라는 아규먼트를 정의해서 재서명할 ipa 파일의 경로를 알려준다. if ipa_path.empty? UI.user_error!(\u0026#34;ipa_path 값을 입력해주세요\u0026#34;) end # 사용될 변수값을 정의한다. 꼭 여기서 정의할 필요는 없고 그냥 이런 식의 변수를 쓸 수 있다는 것을 보여주기 위함. 만약 앱의 scheme을 여럿 쓰고 있다면 ipa_path와 마찬가지로 options에서 scheme을 받아서 이 부분에서 switch문을 통해 각기 다른 값을 넣어주는것을 추천한다. type = \u0026#34;development\u0026#34; bundle_id = \u0026#34;app.bundle.id\u0026#34; profile_path = \u0026#34;프로필이 저장되어있는 경로\u0026#34; profile_filename = \u0026#34;프로필 파일명\u0026#34; signing_identity = \u0026#34;서명 ID\u0026#34; match( readonly: true, type: type, app_identifier: bundle_id, output_path: profile_path ) resign( ipa: ipa_path, signing_identity: signing_identity, provisioning_profile: { bundle_id =\u0026gt; \u0026#34;#{profile_path}/#{profile_filename}\u0026#34; } ) end 이와 같은 방식으로 명령을 지정하면 새 테스터가 추가될 때 마다 이전 빌드의 IPA 파일을 가져와서 match를 통해 저장되어있는 가장 최신의 프로필을 받아오고, 이 프로필을 정해진 ipa 파일에 재서명하면 된다. 아마 Firebase 나 AppCenter에서 최신 빌드 파일을 받는 방법을 제공할 것 같긴 한데 그거는 또 플랫폼별로 방법이 다를거라서 각 플랫폼의 문서를 참고하는 게 좋겠다.\n","permalink":"https://bonoogi.github.io/posts/2023/08/resign-profile/","summary":"애플 플랫폼 앱의 경우, 테스트플라이트를 통해서 테스트 빌드를 배포하는 경우가 많다. 그런데 이게 IPA 파일을 업로드하고 앱스토어커넥트 내부에서 뭔가 조치를 취한 후","title":"Fastlane + Match로 기존 IPA 파일에 새로 갱신한 프로필로 재서명하기"},{"content":"Reactive Programming의 대명사 그 자체인 Reactive Extension(이하 Rx), 그리고 그 중에서도 Apple 생태계 개발자를 위한 Rx 구현인 RxSwift, 그 중에서도 UIKit을 위한 구현인 RxCocoa를 보면 각종 UIKit의 Delegate 패턴에 대응하는 Observable을 제공하고 있다. Rx를 처음 접한 그 당시에는 \u0026lsquo;와 씻 완전 신세계다!\u0026rsquo; 싶어 거의 모든 코드를 Rx 기반으로 작성했었는데, 그래서 Delegate 패턴에 대한 구현도 Rx를 많이 썼던 기억이 난다. 지금은 걍 Delegate를 직접 구현하는 것을 좀 더 선호하는 편이지만\u0026hellip;\n어쨌든, 최근에 진행하는 프로젝트에서 RxSwift 의존성을 Combine으로 이전하는 작업을 했다. 이 때 UIScrollViewDelegate의 scrollViewDidScroll(_ scrollView: UIScrollView) 메서드가 호출될 때의 동작을 Combine으로 처리할 수 있도록 하는 작업도 같이 진행했는데, 이 처리에 대해서 좀 알아보도록 하자.\n일단 세 가지의 타입이 필요하다. Publisher 프로토콜을 구현하는 타입과 Subscription 프로토콜을 구현하는 타입(각 프로토콜이 무슨 역할을 하는지는 문서를 통해 알아보도록 하자). 그리고 UIScrollViewDelegate의 호출되는 메서드가 무엇인지 알려주기 위한 열거형 타입.\n그리고 UIScrollViewDelegate에 대한 구현이기 때문에 UIScrollView에 대한 확장으로 선언하는게 써먹기 편할거라 생각했다. 그러니 결국 다음의 세 타입을 만들게 될 것이다.\nUIScrollView.DelegateEvent(이하 DelegateEvent): UIScrollViewDelegate의 메서드가 호출될 때 호출될 메서드와 인자를 전달해줄 타입. 간단하게 enum으로 구현할 예정이다. UIScrollView.DelegateSubscription(이하 DelegateSubscription): 구독시 구독자에게 이벤트를 전달해줄 타입으로(자세한 것을 애플의 Combine.Subscription 문서를 확인), 실제로 UIScrollViewDelegate를 구현하는 타입이 될것이다. UIScrollView.DelegatePublisher(이하 DelegatePublisher): 이벤트를 전달해줄 게시자 타입. 이 역시 애플의 Combine.Publisher 문서를 확인하자. 위 세가지 타입을 기능만 하도록 구현하면 다음과 같을 것이다. 기본 구현 자체에 대해서는 따로 설명하진 않겠다. Subscription과 Publisher 구현의 경우 SwiftBySundell의 Building custom Combine publishers in Swift을 참고하였으니 해당 아티클을 체크하길 바란다.\nenum DelegateEvent { /// `scrollViewDidScroll(_ scrollView: UIScrollView)` 에 대응하는 케이스 case didScroll(UIScrollView) } class DelegateSubscription\u0026lt;S: Subscriber\u0026gt;: NSObject, UIScrollViewDelegate, Subscription where S.Input == DelegateEvent, S.Failure == Never { private var subscriber: S? init(subscriber: S) { self.subscriber = subscriber } func request(_ demand: Subscribers.Demand) { /* Do Nothing */ } func cancel() { subscriber = nil } // UIScrollViewDelegate 구현 func scrollViewDidScroll(_ scrollView: UIScrollView) { _ = subscriber?.receive(.didScroll(scrollView)) } } struct DelegatePublisher: Publisher { typealias Output = DelegateEvent typealias Failure = Never private let scrollView: UIScrollView init(scrollView: UIScrollView) { self.scrollView = scrollView } func receive\u0026lt;S\u0026gt;(subscriber: S) where S: Subscriber, Never == S.Failure, DelegateEvent == S.Input { let subscription = DelegateSubscription(subscriber: subscriber) subscriber.receive(subscription: subscription) scrollView.delegate = subscription } } 위와 같이 구현하고 UIScrollView의 확장에 계산 프로퍼티로 delegatePublisher를 만들어주면 사용할 수 있다.\nextension UIScrollView { var delegatePublisher: DelegatePublisher { return DelegatePublisher(scrollView: self) } } let scrollView = UIScrollView() let cancellable = scrollView .delegatePublisher .sink { event in switch event { case .didScroll(let scrollView): // Do Something With `scrollView` } } 제법 간단하다. 하지만 이 때 문제가 하나 있다. UIScrollView.delegate는 UIView에 UIGestureRecognizer를 등록하듯이 여러 인스턴스를 추가할 수 있는게 아니고, 한 번에 하나의 delegate만 할당할 수 있기 때문. 그렇기 때문에 아래와 같은 코드에서는 두 번째 delegatePublsher를 호출할 때 첫번째로 호출한 delegatePublisher는 scrollView의 delegate가 아니게 된다.\nvar first = scrollView.delegatePublisher.sink { _ in print(\u0026#34;Useless!\u0026#34;) } var second = scrollView.delegatePublisher.sink { _ in print(\u0026#34;Only Works!\u0026#34;) } // 아래와 같이 해결할 수는 있지만 매번 사용할 때마다 `share()`로 // 별도 인스턴스를 만들어줘야 하기 때문에 실수하기에 너무 좋은 코드이다. let sharedDelegatePublisher = scrollView.delegatePublisher.share() first = sharedDelegatePublisher.sink { _ in print(\u0026#34;It Works!\u0026#34;) } second = sharedDelegatePublisher.sink { _ in print(\u0026#34;It Works, Too!\u0026#34;) } 그렇다면 어떻게 해야 delegatePublisher를 여러번 호출해도 계속 써먹을 수 있을까? 이를 위해서는 두 가지 조건을 만족해야 한다.\nUIScrollView.delegatePublisher가 UIScrollView 인스턴스 하나당 하나만 생성되어야 한다. 매번 새로 생성하면 이전에 생성한 Publisher에 대한 Subscription은 의미가 없어지니까. 위에서 생긴 하나의 DelegatePublisher를 여러 Subscriber가 공유할 수 있어야 한다. Subscriber가 생길때마다 delegate를 할당하면 결국 여전히 최후의 Subscriber만 이벤트를 받을 수 있으니까. 첫번째 조건은 바꿔 말하자면 UIScrollView 인스턴스가 특정되면 거기에 연결된 DelegatePublisher도 특정할 수 있어야 한다는 얘기다. 이에 대해서는 RxSwift가 해결한 방법을 참고했다. 이 친구들은 RxCocoa 내에 DelegateProxyType이라는 타입을 만들어서 별도의 대리자를 만들었고, 이 친구를 UIScrollView 인스턴스에다가 Associated Object로 할당을 하는 식으로 해결하였다. 물론 DelegateProxyType이 Delegate 역할을 하는 것은 아니고, 일종의 연결점이라고 보는게 낫겠지만\u0026hellip;(proxy라는 말을 괜히 쓴게 아님)\n두번째 조건은 잘 생각해보면 어디서 본 말이다. 바로 Publishers.Share다. 애플 문서상에서 이 친구의 정의를 보면 아래와 같이 나와있다.\nA publisher that shares the output of an upstream publisher with multiple subscribers.\nUpstream Publisher의 배출을 여러 Subscriber와 공유하는 Publisher. 결국 두번째 조건은 Share를 사용하면 해결된다. 이를 바탕으로 구현하면 다음과 같은 코드가 만들어진다.\nextension UIScrollView { var delegatePublisher: AnyPublisher\u0026lt;DelegateEvent, Never\u0026gt; { /** `ObjectIdentifier`는 `AnyObject` 인스턴스를 받거나 `Any.Type` 형태의 메타타입을 받아서 ID를 생성할 수 있다. 이 경우에는 `UIScrollView` 인스턴스에 유일한 `DelegatePublisher`를 할당하는게 목표이니 메타타입을 통해 ID를 생성한다. 사실 이렇게 안하고 아래처럼 특정 문자열을 만들어서 그에 대한 UnsafeRawPointer를 만들어도 무방할 것 같다. let someStr = \u0026#34;SomeStr\u0026#34; let rawPointer = \u0026amp;someStr */ let objectIdentifier = ObjectIdentifier(DelegatePublisher.self) let integerIdentifier = Int(bitPattern: objectIdentifier) let rawPointer = UnsafeRawPointer(bitPatter: integerIdentifier)! if let existingPublisher = objc_getAssociatedObject(self, rawPointer) as? AnyPublisher\u0026lt;DelegateEvent, Never\u0026gt; { return existingPublisher } else { let newPublisher = DelegatePublisher(scrollView: self) // 여러 Subscriber가 하나의 Upstream Publisher를 공유 .share() // 반환되는 타입을 맞추기 위함 .eraseAnyPublisher() /** `.OBJC_ASSOCIATION_RETAIN` policy를 지정하면 UIScrollView가 DelegatePublisher에 대해 강한 참조를 갖게 되는데, `.OBJC_ASSOCIATION_ASSIGN` policy를 사용해 약한 참조를 갖게 하면 일부 케이스에서 잘못된 메모리 참조가 일어나기 때문에 `.OBJC_ASSOCIATION_RETAIN`를 사용해 강한 참조를 만들어주는게 좋다 */ objc_setAssociatedObject(self, rawPointer, publisher, .OBJC_ASSOCIATION_RETAIN) return newPublisher } } } 이렇게 하면 UIScrollView 하나당 유일한 delegatePublisher가 생겨나기 때문에 여러번 구독해도 문제가 생기지 않는다. 물론 꼭 Associated Object를 사용할 필요는 없다. 차라리 약한 참조를 갖는 Dictionary 타입을 따로 만들어서 글로벌 스토어로 쓰는게 통제하기는 더 좋을지도 모르겠다. 근데 역시 그건 좀 귀찮아서\u0026hellip;😅\n다만 여전히 아쉬움은 남는다. Publisher가 아닌 형태의 UIScrollViewDelegate와 DelegatePublisher를 함께 사용하고 싶을 수도 있지 않은가. 이 문제도 비교적 간단하게 해결할 수 있다. 아래 코드와 같이 DelegateSubscription에 UIScrollView에 이미 할당된 delegate를 전달하여 약한 참조로 들고 있도록 하고, 모든 UIScrollViewDelegate 메서드를 구현토록 해서 이를 formerDelegate에 전달해주도록 하는 것이다. 물론 delegatePublisher를 먼저 구독한 후 delegate를 새로 할당하면 기대한 대로 움직이지 않겠지만\u0026hellip;(이쯤되면 걍 UIScrollView 자체를 subclassing 하는게 나을듯)\nclass DelegateSubscription\u0026lt;S: Subscriber\u0026gt;: NSObject, UIScrollViewDelegate, Subscription where S.Input == DelegateEvent, S.Failure == Never { private weak var originalDelegate: UIScrollViewDelegate? private var subscriber: S? init(with subscriber: S, originalDelegate: UIScrollViewDelegate?) { self.subscriber = subscriber self.originalDelegate = originalDelegate } ... func scrollViewDidScroll(_ scrollView: UIScrollView) { originalDelegate?.scrollViewDidScroll?(scrollView) _ = subscriber?.receive(.didScroll(scrollView)) } // 이하 나머지 UIScrollViewDelegate 메서드 구현(`originalDelegate`에게 이벤트를 전달하기 위함) } 이걸로 나름 간단하게 Combine을 이용해 Delegate 패턴에 대응하는 방법을 알아봤다. 전체 코드는 따로 Github 저장소에 만들어두었으니 한번 참고해보는 것도 좋겠다.\n참고 SwiftBySundell - Building custom Combine publishers in Swift RxCocoa/DelegateProxyType.swift 애플 공식 문서들 Combine.Publisher Combine.Subscription Combine.Publishers.Share objc_getAssociatedObject(_:_:) objc_setAssociatedObject(_:_:_:_:) ObjectIdentifier ","permalink":"https://bonoogi.github.io/posts/2022/11/delegate-publisher/","summary":"Reactive Programming의 대명사 그 자체인 Reactive Extension(이하 Rx), 그리고 그 중에서도 Apple 생태계 개발자를 위한 Rx 구현인 RxSwift, 그 중에서도 UIKit을 위한","title":"UIKit의 Delegate 패턴에 Combine으로 대응하기"},{"content":"APNs 서버에 통신하기 위해 인증하는 방법은 p8 인증서를 통한 토큰 인증 방식과 p12 인증서를 통한 인증서 인증 방식이 있다. p12 인증서 방식을 사용하면 1년에 한번씩 인증서를 새로 갱신해야 하기 때문에 여간 불편한게 아니기 때문에 아마 대부분은 p8 인증서를 통한 토큰 인증 방식을 사용하고 있을 것이다. 하지만 개발환경이라는게 이래저래 다양하고, 어떤 곳에서는 p12 인증서를 써야할 수 있다. 1년에 한번 하는게 그렇게 어려운 것도 아니고\u0026hellip;\n하지만 1년에 한번이라는게 문제다. 1년만에 해보려니까 이래저래 헷갈릴 수가 있단 말이지. 다행히 애플측에서 인증서 발급과 관련해서 한국어 문서를 제공하고 있기 때문에(인증서 서명 요청 생성하기, TLS 인증서를 사용하여 APNs와 커뮤니케이션하기) 그렇게 어렵지는 않다. 다만 우리측 서버에 등록할 인증서와 키를 p12가 아닌 pem 파일로 변환해서 써야할 때가 있는데, 당연하게도 애플에서 딱히 이를 위한 방법을 알려주진 않는다. 그래서 열심히 검색을 해보면 아래와 같은 방법을 써보라고 나오는데\u0026hellip;\n# 1. 인증서 파일 변환하기 # apns-cert.p12 파일을 apns-cert.pem으로 변환한다고 했을때 $ openssl pkcs12 \\ -clcerts \\ -nokeys \\ -out apns-cert.pem \\ -in apns-cert.key # 2. 키 파일 변환하기 # apns-key.p12 파일은 apns-key.pem으로 변환한다고 했을때 $ openssl pkcs12 \\ -nocerts \\ -out apns-key.pem \\ -in apns-key.p12 이걸 보고 그대로 따라하면 아마 높은 확률로 아래와 같은 오류 메시지를 마주하게 될 것이다.\n\u0026hellip; :digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:349:Global default library context, Algorithm (RC2-40-CBC : 0), Properties ()\n대충 읽어보면 unsupported, Algorithm, RC2-40-CBC와 같은 키워드가 눈에 보인다. 그러니까 정리하자면 RC2-40-CBC 알고리즘을 지원하지 않는다는 얘기인 것 같다. 아마도 애플에서 제공하는 p12 파일의 암호화에 RC2-40-CBC 알고리즘이 쓰이는 모양이다. 그렇다면 방법이 없을까? 그렇지 않다. openssl pkcs12 의 옵션을 차근차근 살펴보면 해당 알고리즘은 사용하도록 하는 옵션인 -legacy 가 있다. 해당 옵션에 대해서는 아래와 같이 설명하고 있다.\nIn the legacy mode, the default algorithm for certificate encryption is RC2_CBC or 3DES_CBC depending on whether the RC2 cipher is enabled in the build. The default algorithm for private key encryption is 3DES_CBC. If the legacy option is not specified, then the legacy provider is not loaded and the default encryption algorithm for both certificates and private keys is AES_256_CBC with PBKDF2 for key derivation.\n축약해서 말하자면 레거시 모드에서는 인증서 암호화를 위한 기본 알고리즘은 RC2_CBC나 3DES_CBC을 쓴단 말이다. 그러니 위의 명령어 입력에 적당히 -legacy 옵션을 껴넣어주면 문제없이 동작하는 것을 알 수 있다.\n","permalink":"https://bonoogi.github.io/posts/2022/07/apns-p12-convert-pem/","summary":"APNs 서버에 통신하기 위해 인증하는 방법은 p8 인증서를 통한 토큰 인증 방식과 p12 인증서를 통한 인증서 인증 방식이 있다. p12 인증서 방식을 사용하면 1년에 한번씩 인증서를","title":"APNs 인증서(p12) 파일을 PEM 파일로 변경중에 오류가 발생했을 때"},{"content":"우선 해결책은 이 링크를 보면 된다.\nSwift Concurrency를 설레는 마음으로 이래저래 써보고 있는데, Xcode 에서 빌드하고 실행한 앱을 홈화면에서 실행할 때마다 Concurrency 관련 기능을 수행하면 갑자기 앱이 강제종료가 되는 상황. 찾아보니 iOS 14 기기에서만 발생하는 것 같다. 위의 링크로 들어가 사람들 얘기하는걸 들어보면 알겠지만, 간단하게 원인을 설명하자면 Swift Concurrency가 이전 버전에서도 동작되도록 넣어준 libswift_Concurrency.dylib 가 일부 환경(Xcode 13.2.1, iOS 14)에서 복수개의 아키텍처에 대한 슬라이스가 동시에 포함되면서 앱이 올바른 라이브러리를 링크하지 못해서 발생하는 상황이었다고. 이를 해결하기 위해서는 결국 해당 dylib가 꼭 필요한 가용한 아키텍처에 대한 슬라이스만 남겨야 하는데, 이를 매 빌드마다 스크립트를 실행하도록 해서 해결할 수 있다고 한다.\n아래 이미지와 같이 앱 Scheme 에디터로 들어가서 Build \u0026gt; Post-actions 에 스크립트를 추가한다. 이 때 Provide build settings from: 바로 뒤에 앱 타겟을 지정해준다.\n그리고 그 아래 다음의 스크립트를 넣어주면 해결이다.\nFRAMEWORK_EXECUTABLE_PATH=\u0026#34;${TARGET_BUILD_DIR}/${WRAPPER_NAME}/Frameworks/libswift_Concurrency.dylib\u0026#34; if test -f \u0026#34;$FRAMEWORK_EXECUTABLE_PATH\u0026#34;; then EXTRACTED_ARCHS=() for ARCH in $ARCHS do echo \u0026#34;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_PATH\u0026#34; lipo -extract \u0026#34;$ARCH\u0026#34; \u0026#34;$FRAMEWORK_EXECUTABLE_PATH\u0026#34; -o \u0026#34;$FRAMEWORK_EXECUTABLE_PATH-$ARCH\u0026#34; EXTRACTED_ARCHS+=(\u0026#34;$FRAMEWORK_EXECUTABLE_PATH-$ARCH\u0026#34;) done lipo -o \u0026#34;$FRAMEWORK_EXECUTABLE_PATH-merged\u0026#34; -create \u0026#34;${EXTRACTED_ARCHS[@]}\u0026#34; rm \u0026#34;${EXTRACTED_ARCHS[@]}\u0026#34; echo \u0026#34;Replacing original executable with thinned version\u0026#34; rm \u0026#34;$FRAMEWORK_EXECUTABLE_PATH\u0026#34; mv \u0026#34;$FRAMEWORK_EXECUTABLE_PATH-merged\u0026#34; \u0026#34;$FRAMEWORK_EXECUTABLE_PATH\u0026#34; fi 맨 위에 링크 건 스레드의 맨 마지막에 보면 Xcode를 13.3 이상으로 업그레이드했을 때 위 스크립트때문에 문제가 발생할 수 있다고 하니 업그레이드 이후에는 꼭 제거하도록 하자.\n물론 macOS Monterey로 업그레이드할 수 있는 환경이라면 이런 뻘짓하지 말고 걍 Xcode 업그레이드하는게 답이다.\n참고 링크 Async Await crash on iOS14 with Xcode 13.2.1 해당 문제를 재현하기 위해 (누군가가) 만든 프로젝트 저장소 ","permalink":"https://bonoogi.github.io/posts/2022/05/swift-concurrency-backport-error/","summary":"우선 해결책은 이 링크를 보면 된다. Swift Concurrency를 설레는 마음으로 이래저래 써보고 있는데, Xcode 에서 빌드하고 실행한 앱을 홈화면에서 실행할 때마다 Concurrency","title":"[iOS] Xcode 13.2.1 에서 불가사의한 이유로 Swift Concurrency 쪽에서 EXC_BAD_ACCESS 오류가 발생할 때"},{"content":"Intro 갑자기 직접 호스팅하는 블로그를 쓰고싶어져서 깃헙 페이지에 휴고로 만든 사이트를 올려놨다. 하는 김에 휴고 공식 문서를 참고해 깃헙 액션을 통한 자동 배포 설정도 추가하고. 근데 이 문서의 예제대로만 하면 깃헙 페이지 저장소에 단순히 프론트에 노출되는 파일 뿐 아니라 휴고 사이트 설정 파일이나 커스텀 레이아웃 파일 등도 포함되어야 한다. 물론 엄청나게 민감한 정보를 포함되지는 않지만 그래도 좀 찝찝하다. (완전히 동일한 비유는 아니지만) 저장소에 백/프론트가 함께 올라가있고, 거기에 누구나 접근할 수 있는 느낌이랄까?\n이렇게 다 들고 있을 필요가 있냐 이 말이지 기존 배포 코드 알아보기 name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.91.2\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 위 코드는 깃헙 액션 마켓플레이스에 있는 Hugo setup에 올라와있는 예시 코드이다. 이것들을 다 설명할 필요는 없고, 쭉쭉쭉쭉 내려와서 jobs \u0026gt; deploy \u0026gt; steps 아래 중에 Setup Hugo부터 보자.\nSetup Hugo - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.91.2\u0026#39; # extended: true 일단 얘는 peaceiris/actions-hugo@v2를 사용한다. 이거는 현재 액션을 수행하는 머신에 휴고 환경을 만들어주는 액션이다. 여기서는 보시다시피 사용할 휴고 버전을 명시할 수 있다. 본인이 원하는 대로 설정하자. 휴고 모듈을 캐싱한다던가, 저장소 내에 환경변수를 지정해 휴고 버전을 지정한다던가 하는 것은 굳이 여기서 얘기하지 않겠다. 위에서 링크를 걸어둔 Hugo setup 마켓플레이스 페이지로 가면 다 나와있다.\nBuild \u0026amp; Deploy - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 휴고 환경설정을 해줬으니 빌드는 간단하다. hugo --minify를 실행해준다. 이 명령어에 대한 설명은 Hugo CLI 문서의 \u0026lsquo;options\u0026rsquo; 항목에서 찾을 수 있다. 간단하게\nminify any supported output format (HTML, XML etc.)\n라고 설명하고 있는데, 말 그대로 사이트 서빙을 위한 최소화된 파일을 생성해준다고 보면 된다.\n빌드를 했으니 배포해야겠지? 배포에는 peaceiris/actions-gh-pages를 사용한다. 깃헙 페이지를 위한 액션으로 이 역시 마켓플레이스에서 자세한 내용을 찾을 수 있다. 간단하게 설명하자면 publish_dir에서 지정한 디렉토리의 내용을 지정된 브랜치(기본값은 gh-pages)로 배포하는 것이다. 지금은 휴고 사이트 코드와 생성된 코드가 동일한 저장소에 존재하기 때문에 별도의 설정 없이 단순히 ${{ secrets.GITHUB_TOKEN }}으로 깃헙이 자동 생성해주는 토큰을 사용할 수 있다. 여기까지의 흐름은 다음과 같다(클릭하면 크게 볼 수 있다).\n하지만 우리의 목적은 이게 아니다. 깃헙 페이지 저장소가 아닌 별도의 저장소에 코드를 푸쉬하면 깃헙 액션 러너가 해당 코드를 기반으로 빌드하고 그 결과물만 깃헙 페이지 저장소에 배포해야 하는 것이다.\n사이트 코드 저장소의 깃헙 액션을 통해 페이지 저장소 코드에 배포하기 일단 우리가 원하는 모양새가 무엇인지 명확히 하기 위해 한번 더 도표를 그려보겠다(클릭하면 크게 볼 수 있다).\n차이가 느껴지는가? 별도로 소스 코드를 지니는 private 저장소를 마련해두고, 이 저장소에 코드가 푸쉬되면 액션을 수행하도록 하는 것이다.\nAction 수정 이때 전체적인 흐름은 위에서 보여준 yaml 파일과 비슷하지만, Deploy 부분이 약간 다르게 구성된다. 대충 이런 식이다.\n- name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: deploy_key: ${{ secrets.GH_ACTION_DEPLOY_KEY }} external_repository: XXX/XXX.github.io publish_branch: main publish_dir: ./public 다른 부분은 다 같은데, 세 부분이 다르다. 바로 deploy_key, external_repository, publish_branch다. deploy_key에 대해서는 잠시 미뤄두고, 나머지 두 개를 먼저 살펴보자.\nexternal_repository는 말 그대로 외부 저장소를 말한다. 위의 도표를 보면 알다시피 Github Pages 저장소가 아닌 별도의 소스 코드 저장소에서 실행되는 액션이기 때문에 프론트 코드가 배포될 Github Pages 저장소를 따로 명시해야한다. 이 경우에는 사용자명이 XXX라 치고 값을 써두었다.\npublish_branch는 Github Pages의 프론트 코드가 main 브랜치로 배포되도록 지정한 것이다. peaceiris/actions-gh-pages 액션의 기본 설정은 사용자로 하여금 Github Pages 저장소의 main 브랜치가 아닌 별도의 브랜치(gh-pages)에 프론트 코드가 푸쉬되도록 한다. 그러면 이 별도의 브랜치에는 사이트 코드를 제외한 프론트 코드만 남아있어 하나의 저장소에서 두개의 코드를 들고 있는 것처럼 관리할 수 있다. 하지만 우리는 아예 저장소 자체를 분리해버렸기 때문에 브랜치로 소스를 분리할 필요가 없다. 그러니 그냥 main 브랜치로 배포하도록 지정하는 것이다.\ndeploy_key는 Github Pages 저장소에 생성된 코드를 배포하기 위한 배포키를 적는 곳이다. 그렇다면 왜 갑자기 배포키가 필요한 것일까? 이전 예시에서는 액션을 수행하는 저장소와 코드가 배포될 저장소가 동일한 저장소였기 때문에 자동으로 생성되는 토큰을 사용해도 문제가 없었다. 하지만 지금같은 경우에는 액션이 수행되는 저장소와 코드가 배포될 저장소가 다르기 때문에 자동으로 생성되는 토큰을 사용할 수 없다. 이와 같은 상황에 대비해 Github에서는 저장소별 Deploy Key를 지정하는 기능을 제공한다.\n생성된 코드를 배포하기 위한 Deploy Key 적용 Github Docs의 Generating a new SSH Key 문서를 참고해 배포를 위한 SSH 키쌍을 생성한다. 이 때 공개키와 비밀키가 한 쌍 생성되는데, 이걸 배포키로 등록하는 것이다.\nGithub Pages 저장소의 Settings 탭으로 이동하고 Deploy Key 메뉴로 들어간다. 그리고 오른쪽 위에 있는 \u0026lsquo;Add deploy key\u0026rsquo;를 눌러 진입한 페이지에서 필요한 내용을 붙여넣는다. 이후 \u0026lsquo;Allow write access\u0026rsquo;를 체크하고 \u0026lsquo;Add key\u0026rsquo; 버튼을 클릭하면 배포 키가 등록된 것이다. 이때 \u0026lsquo;Allow write access\u0026rsquo; 를 체크하지 않으면 배포키가 있어봤자 코드 푸쉬를 할 수 없으니 의미가 없다. 꼭 체크해주도록 하자.\n이걸로 Github Pages 저장소에 코드 배포를 할 수 있는 배포키의 공개키를 등록하는 작업을 완료했다. 이 공개키는 일종의 전용 출입문으로, 열쇠가 있다면 이 문을 통해 배포 작업을 수행할 수 있다. 그러면 이제는 액션을 수행하는 저장소에다가 출입문 열쇠를 알려줘야겠지? 별도로 마련한 깃헙 액션을 수행하는 휴고 사이트 코드 저장소의 Settings 탭으로 이동하고 Secrects 메뉴 아래 Actions 메뉴에 들어가 오른쪽 위의 \u0026lsquo;New repository secret\u0026rsquo; 버튼을 눌러 비밀키 입력 화면을 들어간다. 해당 화면에서 Name에는 Github Actions의 선언파일에서 호출할 Secret의 변수명을 지정한다. 아까 위에서 deploy_key: ${{ secrets.GH_ACTION_DEPLOY_KEY }} 라는 부분이 있었을텐데, 이 GH_ACTION_DEPLOY_KEY가 이에 해당한다. Value에는 비밀키 내용을 빠짐없이 붙여넣는다(Begin 어쩌구 End 어떠구 하는 부분 포함).\n이제 액션을 수행할 저장소에게 적절한 열쇠를 쥐여주고, 배포 동작을 할때 어떤 열쇠를 들고가야할지 알려주었으니 뭔가 변경사항을 만든 다음에 코드를 푸쉬해보자. 알아서 배포가 착착 진행되는 것을 확인할 수 있다.\n","permalink":"https://bonoogi.github.io/posts/2022/04/01-deploy-github-pages-from-other-repo/","summary":"Intro 갑자기 직접 호스팅하는 블로그를 쓰고싶어져서 깃헙 페이지에 휴고로 만든 사이트를 올려놨다. 하는 김에 휴고 공식 문서를 참고해 깃헙 액션을 통한 자동 배포 설정도 추","title":"분리된 코드 저장소에서 깃헙 액션을 통해 깃헙 페이지 배포하기"},{"content":"Combine이든 RxSwift든 리액티브 프로그래밍 프레임워크를 다루다보면 한번씩 마주하게 되는 문제가 몇가지 있다. 하나는 메모리 관리 문제고(보통 이건 초심자가 많이 겪는다), 또 하나는 배압(Backpressure) 문제다. 리액티브 프로그래밍에서 배압이란 무엇을 말하는가? 구독자와 게시자가 있다고 할 때, 구독자가 값(혹은 이벤트)을 소비하는 속도가 게시자가 값을 보내는 속도를 따라가지 못하는 상황을 일컫는다. 이게 원래는 유체동역학 용어(위키백과: Back Pressure)라는데, 프로그래밍 관점에서 리액티브 프로그래밍이라는게 값의 흐름이니 정말 적절한 용어가 아닌가 싶다.\nBy Engr.Nithin Mohandas - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=74922539 여튼 이런 배압 문제는 일반적으로는 쉽게 발생하지 않는다. 일반적으로 리액티브 프로그래밍을 비동기 처리를 위해 사용하다보니 게시자의 값 송출이 감당하지 못할만한 상황이 자주 일어나지 않기 때문이다. 그렇기 때문에 앞에서 초심자가 많이 겪는 메모리 관리 문제보다는 좀 더 리액티브 프로그래밍을 헤비하게 사용하는 경우 맞닥뜨리기 쉽다(앱에서 발생하는 온갖 이벤트를 다 리액티브하게 처리를 한다던가\u0026hellip;). 예를 들어 기기의 자이로 센서 등을 통해 값을 계속해서 전달받는 경우가 있다고 하자. (센서의 민감도에 따라 다르겠지만) 1초 사이에 어마어마하게 많은 값을 받게 될 수도 있다. 이런 경우에는 차라리 특정 시간차를 두고 그 사이에 온 최초 혹은 최후 혹은 어떤 하나의 값을 받아도 문제가 없을 것이다.\nReactiveX의 경우에는 throttle이나 debounce, buffer 등의 연산자를 활용하거나 경우에 따라 적절한 Cold/Hot Observable을 사용하라는 식의 지침이 있다(ReactiveX: Back pressure operators).\n그렇다면 Combine의 경우에는 어떤 식으로 처리할 수 있을까? 우선, Combine도 Throttle이나 Debounce, Buffer와 같은 사전정의된 Publisher를 제공한다. 사실 이것들만 잘 활용해도 어지간한 케이스에는 대응할 수 있다.\n하지만 게시자(Publisher)와 구독(Subscription)을 직접 구현하는 방법으로도 배압을 통제할 수 있다. Combine은 구독자(Subscriber)가 게시자로부터 값을 당겨오는 메커니즘을 사용한다. 이때 구독자는 게시자에게 Subscribers.Demand라는 구조체를 전달해 얼만큼의 값을 당겨올지 요청할 수 있다. 그리고 이 Demand를 조절하는 방식으로 값을 당겨오는 것을 통제해 배압 문제를 처리할 수 있는 것이다. 예를 들어 외부에서 Demand를 통제할 수 있는 커스텀 구독자를 만들고, 상황에 따라 이 구독자의 참조를 지닌 상태에서 값의 처리가 힘든 상황이 되면 잠시 값을 당겨오지 않도록 했다가 다시 준비가 되면 당겨올 수 있도록 하는 것이다.\n이 때 주의할 것이 하나 있는데, Demand를 조절하는 방법에는 가산(add)만이 존재한다는 것이다. 예를 들어 이미 .max(5)와 같은 Demand가 동작을 하고 있다면, 3번째 값을 받고 .none을 전달해 더이상 값을 받지 않겠다고 해도 앞선 .max(5)에 따라 4번째, 5번째 값을 받고 나서야 .none이 효력을 발휘한다. 그렇기 때문에 직접적으로 Demand를 조절하고자 하는 경우에는 .max(1)과 같이 한번에 하나씩의 값을 받는 식으로 처리하는게 좀 더 유용할 것이다(무조건 이렇게 하라는 건 아니다!).\n","permalink":"https://bonoogi.github.io/posts/2022/03/01-combine-backpressure/","summary":"Combine이든 RxSwift든 리액티브 프로그래밍 프레임워크를 다루다보면 한번씩 마주하게 되는 문제가 몇가지 있다. 하나는 메모리 관리 문제고(보통 이","title":"[Swift] Combine의 Backpressure 처리"},{"content":"iOS 15에서 AttributedString이 추가되면서 일부 SDK 기능을 쓸 때 NSAttributedString 대신에 AttributedString을 사용해야할 때가 있는데, 이게 또 바로바로 호환이 되질 않는다. 아래와 같이 별도의 생성자를 통해 만들어줘야 한다.\nlet nsAttributedString = NSAttributedString(...) // UIKit 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \\.uiKit) // SwiftUI 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \\.swiftUI) // AppKit 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \\.appKit) // Foundation 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \\.foundation) NSAttributedString의 모든 속성을 바로 가져올 수는 없고, 위와 같이 특정 스코프를 지정하면 그 스코프에 맞는 속성을 뽑아오는 개념이다. 솔직히 불편한데\u0026hellip;걍 처음부터 AttributedString으로 만들고 NSAttributedString으로 변환하는게 나을듯\u0026hellip;\n참고 링크 NSAttributedString(_ attrStr: AttributedString) AttributedString(_ nsStr: NSAttributedString, including scope: KeyPath\u0026lt;AttributedScopes, S.Type\u0026gt;) throws where S: AttributedScope AttributedString(_ nsStr: NSAttributedString, including scope: S.Type) throws where S: AttributedScope AttributedScopes ","permalink":"https://bonoogi.github.io/posts/2022/02/04-convert-nsattributedstring/","summary":"iOS 15에서 AttributedString이 추가되면서 일부 SDK 기능을 쓸 때 NSAttributedString 대신에 AttributedString을 사용해야할 때가 있는데, 이게 또","title":"NSAttributedString을 AttributedString으로 변환하기"},{"content":"원래는 이전 글에서 Combine Scheduler에 대해 좀 더 알아보는 글을 쓰려고 했는데, 방향에 가닥이 잡히질 않아 다른것부터 쓰기로 했다. 뭔고 하니, 바로 Combine 코드를 단위 테스트하는 방법이다. 현재 개발중인 프로젝트에서는 많은 코드를 Combine 기반으로 작성하고 있기 때문에 테스트 코드 역시 Combine에 맞춰서 구현하게 된다. 그렇다면 어떻게 Combine 코드를 테스트할 수 있을까? 공통점 하나와 차이점 하나로 설명해보겠다.\n공통점: setUp과 tearDown Combine 테스트라면 당연하게도 Publisher를 구독하고 값을 받거나 종료 이벤트를 받는 시점에 받은 값을 검증해야 할 것이다. 그렇다면 결과적으로 Publisher를 구독했을 때 반환되는 Cancellable에 대한 처리가 필요하다는 것이다. 만약 이런 부분을 간과한다면, 어딘가에서부터 이유를 알 수 없이 깨지는 테스트 케이스가 발생하게 될 것이다.\nimport XCTest import Combine class CombineTest: XCTestCase { // 초기화 var subscriptions = Set\u0026lt;AnyCancellable\u0026gt;() override func tearDown() { // 종료된 테스트 케이스의 Cancellable에 대해 초기화 처리 subscriptions = [] } } 차이점: 동기냐 비동기냐 사실 Combine이나 XCTest 프레임워크 상에서 별도로 Combine만을 위한 테스트 도구를 제공하지는 않는다. 예를 들어, RxSwift에는 TestScheduler가 있어 가상으로 이벤트의 시간을 조정할 수 있다. 그렇기 때문에 특히나 비동기로 이루어지는 작업에 대한 테스트에 대한 기대값을 조정하기에 편하다. 하지만 Combine에는 그런게 없다. 기존에 제공하는 도구로도 충분히 모든 것을 테스트할 수 있다는 자신감이 아닌가 싶다(물론 실제로도 기존 도구로 모든 테스트가 가능).\n동기 테스트 동기적인 동작에 대한 테스트는 간단하다. 간략하게 순서로 얘기하자면 다음과 같다.\n테스트할 결과값을 받아와 저장하는 변수와 테스트하고자 하는 성공/실패 기대값을 준비한다. 테스트하고자 하는 Publisher를 준비한다. Publisher를 구독하고 값을 받는 클로져(receiveValue or receiveCompletion)에서 결과값을 저장하는 변수에 값을 저장한다. 테스트하고자 하는 기대값과 비교한다. 만약 생성자를 통해 주어진 인자를 소문자화하는 커스텀 Publisher인 LowerCased가 있다고 하자. 그렇다면 이 Publisher에 대해서는 어떻게 테스트해야할까? 다음 코드가 아마 힌트가 될 것이다.\n// Publisher.LowerCased\u0026lt;String, Never\u0026gt;가 제대로 주어진 값을 소문자화하는지 테스트 func test_lowerCased() { // 1 - 결과값을 저장할 변수와 기대값 변수 선언 var result: String = \u0026#34;\u0026#34; let expect: String = \u0026#34;foo\u0026#34; // 2 - 테스트할 Publisher Publisher.LowerCased(\u0026#34;FOO\u0026#34;) .sink(receiveValue: { // 3 - 결과값 저장 result = $0 }) .store(in: \u0026amp;subscriptions) // 4 - 결과 검증 XCTAssertEqual(result, expect) } 위에서 얘기한 순서에 해당하는 부분에 주석으로 숫자를 남겨놨다. 이 테스트케이스의 경우 모든 것이 동기적으로 동작할 것이라는 것이 기대되기 때문에 결과값을 클로져 내부에서 받아온다고 하더라도 신경쓸 필요가 없다. 그저 순차적으로 동작할 것을 기대하고 테스트 코드를 작성하면 되는 것이다.\n그렇다면 만약 ViewModel과 같은 역할을 하는 클래스를 테스트한다면 어떻게 해야할까? 이 경우에도 크게 다르지 않다. 아래와 같은 클래스가 있다고 생각해보자. 아래 클래스는 문자열을 입력하면 lowerCased 변수에 입력한 문자열을 소문자로 변환해 저장하는 클래스이다.\nclass LowerCaseViewModel: ObservableObject { @Published private(set) var lowerCased: String = \u0026#34;\u0026#34; func setValue(_ text: String) { lowerCased = text.lowerCased() } } 이 경우 다음과 같은 테스트가 가능할 것이다.\nclass LowerCaseViewModelTest: XCTestCase { var viewModel: LowerCaseViewModel! var subscriptions = Set\u0026lt;AnyCancellable\u0026gt;() override func setUp() { viewModel = LowerCaseViewModel() } override func tearDown() { subscriptions = [] } func test_lowerCased() { var result: String = \u0026#34;\u0026#34; let expected: String = \u0026#34;foo\u0026#34; viewModel.$lowerCased .sink(receiveValue: { result = $0 }) .store(in: \u0026amp;subscriptions) viewModel.setValue(\u0026#34;FOO\u0026#34;) XCTAssertEqual(result, expected) } } viewModel.$lowerCased는 실제로는 [\u0026quot;\u0026quot;, \u0026ldquo;foo\u0026rdquo;]의 두 개 값이 방출되고, 딱히 종결이벤트가 발생하지 않지만 해당 테스트 케이스는 동기적 이벤트 발생에 대한 흐름을 쫓고 있기 때문에 결과값이 기대값인 \u0026ldquo;foo\u0026quot;와 동일하기 때문에 의도한대로 성공하는 테스트 케이스가 되는 것이다.\n그렇다면 이번엔 Combine의 비동기 동작은 어떻게 테스트할 수 있는지 알아보자.\n비동기 테스트 위의 동기 동작에 대한 테스트 코드를 보면 사실 일반적인 테스트 코드를 작성하는 것과 그렇게까지 큰 차이가 없다는 것을 알 수 있다. 그렇다면 비동기 동작에 대한 테스트는? 그렇다. 흔히 활용하는 completionHandler에 대한 테스트와 비슷하게 처리할 수 있다. 바로 XCTestExpectation을 사용하는 것이다. 그 전에, 일단 아래와 같은 ViewModel 클래스가 있다고 가정해보자.\nclass FooViewModel: ObservableObject { private let fetcher = BarFetcher() @Publisher private(set) var fetchedData: String = \u0026#34;\u0026#34; func fetch(for keyword: String) { fetcher.fetchAsync(for: keyword) .assign(to: \u0026amp;$fetchedData) } } 어떤 키워드를 입력하면 어딘가로부터 키워드에 맞는 데이터를 가져와 fetchedData에 해당 데이터를 넣어주느 동작을 하는 ViewModel이다. 이 경우에는 키워드에 맞는 데이터를 비동기적으로 가져오는 동작밖에 할 수 없기 때문에 위의 동기 테스트 코드로는 처리할 수 없다. 하지만 이를 위해 위에서 언급한 XCTestExpectation이 존재하는 것이다. 간략한 사용방법은 아래 코드로 알 수 있으나, 자세하게 알고 싶다면 애플 개발자 문서를 찾아보자.\nfunc test_fetchAsync() { var result = [String]() let expected = [\u0026#34;some text data for keyword\u0026#34;] // 비동기 작업에 대해 대기하도록 하는 XCTestExpectation 생성 let expectation = self.expectation(description: #function) viewModel.$fetchedData .dropFirst() .prefix(1) .sink( receiveCompletion: { _ in // 이벤트 종료와 함께 expectation에 대기 종료할 것을 알린다 expectation.fulfill() }, receiveValue: { result.append($0) } ) .store(in: \u0026amp;subscriptions) viewModel.fetch(for: \u0026#34;keyword\u0026#34;) // XCTestExpectation의 종료 메시지를 대기하도록 하는 명령. 최대 5초간 기다리도록 지정. waitForExpectations(timeout: 5, handler: nil) XCTAssertEqual(result, expected) } XCTestExpectation의 사용법은 주석으로 대강 알아볼 수 있을 것이다. 여기서 확인해야하는 것은 viewModel.$fetchedData의 뒤에 달라붙어있는 dropFirst()와 prefix(1)이다. 그렇다면 왜 이런 연산자를 사용해야 하는걸까?\n첫번째로 dropFirst를 쓴 이유는 다음과 같다. viewModel.$fetchedData의 경우 초기값이 있는 Publisher다. 이 경우 dropFirst가 없으면 result가 초기값까지 받아 배열에 넣기 때문에 expected 값과 비교하면 테스트 실패라고 나올 것이다. 물론 최종 결과값만 보고 비교해도 상관없다면 기대값과 결과값을 [String]이 아닌 String 타입으로 놓고 비교하면 될 일이다. 하지만 Combine이라는 것은 결국 이벤트 스트림에 대한 것이고, 이에 대해 테스트하기 위해서는 이벤트 스트림 자체에 대한 검증이 필요해지는 것이다(그래서 적절한 TestScheduler가 있으면 더 좋다). 이런 것들은 명시적/암시적으로 환기해가면서 주지하지 않으면 금방 까먹을 수 있기 때문에 개인적으로 위와 같은 패턴을 즐겨 쓰는 편이다.\n두번째로 prefix를 쓴 이유는 다음과 같다. viewModel.$fetchedData는 ViewModel 자체가 deinit되지 않는 한 이벤트 스트림이 종결될 일이 없다. 이벤트 스트림이 종결되지 않는다면 적절한 시점에 expectation.fulfill이 호출되지 않기 때문에 waitForExpectations로 지정한 시간제한에 걸리고 만다. 이런 일을 피하기 위해서는 prefix와 같은 연산자를 통해 이벤트 스트림에 대한 추적을 얼마만큼 할 것인지 지정해야 한다.\n위의 두 연산자를 반드시 써야한다는 것이 아니다. 비동기 동작에 대한 테스트를 할때는 이벤트 스트림에 대한 검증을 해야한다는 것을 잊으면 안된다는 것이다. 특히나 ViewModel과 같은 클래스는 뷰의 상태에 직접적으로 관여하는 경우가 많기 때문에 더더욱 이를 유념해야 한다. 예를 들어 뷰 안에 스위치가 있고, 이 스위치를 전환할때 어떤 비동기 동작을 진행한 후 스위치와 바인딩된 Bool 값이 변경된다고 생각해보자. 비동기 동작을 한 번 진행할때 스위치에 바인딩된 Bool값이 두번 세번 네번 변경된다? 그러면 사용자는 단 한번의 상호작용을 했을 뿐인데 그에 대한 결과를 두번 이상 목격하게 되고, 결과적으로 혼란을 겪게 될 것이다. 이 역시 중요한 버그라고 할 수 있으니 꼭 검증해야 하는 요소라고 할 수 있다.\n결론 오늘은 Combine의 스케쥴러가 아닌 테스트에 대해 알아봤다. 일반적인 테스트 코드 작성법과 크게 다르지 않지만, 어떤 경우에는 단순 값에 대한 검증이 아니라 이벤트 스트림에 대한 검증을 해야한다는 차이가 있었다. 이것만 유념한다면 Combine 코드에 대한 테스트 케이스 작성 및 검증에 큰 어려움을 겪지는 않을 것이다.\n","permalink":"https://bonoogi.github.io/posts/2022/02/03-testing-combine/","summary":"원래는 이전 글에서 Combine Scheduler에 대해 좀 더 알아보는 글을 쓰려고 했는데, 방향에 가닥이 잡히질 않아 다른것부터 쓰기로 했다. 뭔고 하니, 바로 Combine 코드를 단","title":"[Swift] Combine 테스트 하기"},{"content":" Customize handling of asynchronous events by combining event-processing operators.\nSwift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리를 거의 완전히 대체할 수 있다(애시당초 대체하라고 나왔다고 볼 수 있다). Combine이나 Reacive Extension과 같은 형태를 일반적으로 Reactive 혹은 반응형 프로그래밍이라고 부른다. 이게 명칭때문에 React나 반응형 웹 디자인과 개념을 헷갈려하는 사람이 종종 보이는데, 전혀 다른 개념이다.\n여튼 이런 반응형 프로그래밍의 장점이자 특징이라고 한다면 바로 연산자 호출을 통한 작업 스레드 전환이다. 그리고 이 특징이 비동기 작업을 용이하게 만들어주는 것이기도 하고. 그렇다면 Combine 프레임워크에서는 어떻게 스케쥴러를 통해 스레드 전환을 할 수 있는지, 그리고 스케쥴러를 활용한 다른 기능은 뭐가 있는지 알아보자.\nNOTE\n참고로 스케쥴러와 스레드는 서로 다른 객체이다. 간단히 설명하자면, 스케쥴러가 구현된 세부사항에 따라 적절한 스레드를 사용하도록 지시하는 것과 비슷하다. 실제로 자세히 들어가면스케쥴러의 구현체 각각이 스레드를 어떤 식으로 사용하는지가 다 다르다.\nsubscribe(on:)과 receive(on:) subscribe(on:)과 receive(on:)은 위에서 언급한 스케쥴러를 통한 스레드 전환을 수행하는 연산자다. 둘의 동작 차이는 메서드명을 간단하게 문장으로 풀이해서 번역해보면 느낌이 올 것이다.\nsubscribe(on scheduler: S) \u0026gt; subscribe on scheduler S \u0026gt; 스케쥴러 S에서 구독 receive(on scheduler: S) \u0026gt; receive on scheduler S \u0026gt; 스케쥴러 S에서 수신(혹은 수령?) 어떤가 느낌이 좀 오는가? 여기서 Combine Scheduler 프로토콜의 정의인 \u0026lsquo;클로져를 언제 어떻게 실행할지 정의하는 프로토콜\u0026rsquo;을 생각하면, subscribe(on:)은 구독하려는 클로져에 대해 스케쥴러를 지정하는 것이고, receive(on:)은 수신하는 클로져에 대해 스케쥴러를 지정하는 것이라고 볼 수 있다. 물론 이것만으로는 아직 이해가 어려울 수 있다. 그렇다면 쉬운것부터 생각해보자.\n수신하는 클로져란 무엇일까? Combine은 데이터 그 자체보다는 데이터의 흐름을 다루는 프레임워크다. 이런 관점에서 수신하는 클로져란 무엇일지 생각해보면, 데이터의 흐름을 받아 뭔가 조작을 가하거나 하는 클로져를 말한다는 것을 알수 있다. 예를 들어, .map(_:)과 같은 연산자를 생각해보자. 이 친구의 경우에는 클로져를 인자로 받아 그 클로져에서 데이터 흐름을 통해 흘러들어온 데이터에 조작을 가한후 다음 흐름으로 보내주는 역할을 한다. 그렇다. 이 .map(_:) 메서드가 받은 클로져가 바로 수신하는 클로져다. 고로 receive(on:) 은 이런 map과 같은 메서드에 인자로 넘어가는 클로져를 언제/어떻게 실행할지 정의해놓은 스케쥴러를 지정하는 거라고 볼 수 있다.\n그렇다면 구독하는 클로져란 무엇인가? 구독이 발생하는 지점의 클로져를 말한다. 예를 들면 다음과 같다.\nfunc doSubscribe() { // Closure 0 SomePublisher() .handleEvents(receiveSubscription: { _ in // Closure 1 // 여기서 스레드를 체크하면 Closure 0과 동일한 스레드가 나온다. }) .sink(/* ... */) } doSubscribe 함수에서 SomePublisher를 구독하고 있다. 이때 이 구독하는 이벤트가 발생하는 doSubscribe의 몸체 클로져가 바로 이 구독하는 클로져이다. 이 때 doSubscribe가 메인 스레드에서 수행된다면 구독 역시 메인 스레드에서 수행된다. 하지만 아래처럼 별도의 subscribe(on:) 을 호출해 global 큐를 사용하도록 한다면?\nfunc doSubscribe() { // Closure 0 SomePublisher() .subscribe(on: DispatchQueue.global()) .handleEvents(receiveSubscription: { _ in // Closure 1 // doSubscribe가 어느 스레드에서 수행되었는지는 몰라도 적어도 여기서는 백그라운드 스레드에서 수행된다. }) .sink(/* ... */) } doSubscribe가 어느 스레드에서 수행되었는지와 상관없이, 구독 이벤트가 발생하는 시점의 스레드는 DispatchQueue.global() 에 의해 수행 시점의 적절한 백그라운드 스레드로 전환되는 것이다.\n참고할 것은 subscribe(on:)은 업스트림에 영향을 미치기 때문에 2회 이상 호출되었을 경우 근원이 되는 업스트림에 가까운 메서드에 인자로 넘김 스케쥴러의 명령을 따르게 된다.\n그렇다면 이 인자로 넘기는 스케쥴러는 무엇이고 또 어떤게 있으며, 어떤 상황에 어떤 스케쥴러를 사용해야 하는걸까? 이에 대해서는 좀 더 정리해서 다음 포스팅에서 얘기해보도록 하겠다(언젠간\u0026hellip;).\n","permalink":"https://bonoogi.github.io/posts/2022/02/02-combine-schedulers/","summary":"Customize handling of asynchronous events by combining event-processing operators. Swift Combine 프레임워크는 위의 인용구에 나와있다시피 비동기 작업을 용이하게 처리하기 위한 프레임워크로, Reactive Extension과 같은 라이브러리","title":"[Swift] Combine의 Scheduler 전환에 대해 알아보기"},{"content":"프로젝트별로 상황이야 다르겠지만, SwiftUI 프리뷰를 사용할 때 빌드하는 시간이 너무 오래 걸리면 \u0026ldquo;야 이거 너무 오래 걸려서 프리뷰 기능을 잠깐 멈췄어. 준비되면 Resume 버튼을 누르렴\u0026rdquo; 식의 안내 메시지가 나온다. 그래서 Resume을 누르면? 또 한참을 빌드하다가 저 메시지를 또 보여준다. 그래서 Resume을 또 누르면? 또 한참을 빌드하다가\u0026hellip;\n라는 어떤 재귀적인 기분이 드는 상황을 맞닥뜨리는 경우가 있다. 아니 그런데 솔직히, 프리뷰하나 띄우는 빌드가 그렇게 오래걸릴수가 있나? 프리뷰 빌드가 무슨 클린 빌드도 아니고, 뭔가 프로젝트가 동쪽으로 서쪽으로 유유히 표류하는 것도 아닐텐데 말이다.\n바로 그 상황에서 여러분이 체크해야하는 것이 있다. 바로 앱 프로젝트의 Build Phases 설정이다. Xcode 프로젝트에서 프로젝트에 각종 분석 도구를 붙이거나, 뭔가 정적으로 코드를 생성하는 작업 등을 자동으로 수행하도록 할 때 1차적으로 찾는 것이 바로 이 Build Phases다. 번역하면 빌드 단계, 그러니까 빌드를 수행하면 여기 정의한 순서대로 스크립트가 됐든 뭐가 됐든 이 작업도 같이 하라는 식으로 이것저것 붙일 수 있는 것이다.\n내 경우에는 이 Build Phases에 Firebase Crashlytics에 dSYM을 업로드하는 스크립트와 SwiftLint, SwiftGen, Apollo CodeGen 작업을 수행하는 스크립트등을 추가해놨었다. 근데 빌드를 돌리고 나중에 보고서를 체크해보니 Apollo CodeGen과 dSYM 업로드가 생각보다 너무 많은 시간을 잡아먹는게 아닌가? 사실상 매번 빌드할때마다 수행할 필요도 없는데\u0026hellip; 내가 터미널에 명령어 한번 입력하는 횟수 줄이겠다고 한 짓이 SwiftUI 프리뷰조차 쓰지 못하게 한 것이다. 하지만 걱정 마라. 다 방법이 있다. 바로 작업 수행 시간이 오래 걸릴만한 Build Phase 스크립트의 상단에 아래와 같은 코드를 추가하는 것이다.\nif [ $ENABLE_PREVIEWS = YES ] then echo \u0026#34;SwiftUI Preview 빌드중에는 이 빌드 단계를 무시합니다.\u0026#34; exit 0 fi # 필요하지만 어쨌든 오래 걸리는 작업... ENABLE_PREVIEWS는 Xcode에서 SwiftUI 프리뷰를 위한 빌드일때 갖고있는 내부 변수같은거라고 생각하면 된다. 만약 시간이 오래 걸리는데 굳이 모든 빌드중에 필요하지 않은 빌드 단계가 있다면, 위와 같은 조건 분기를 만들고 exit 0 명령어를 통해 해당 단계를 정상종료 시켜버리면 되는 것이다. 자, 이제 시뮬레이터도, 디버깅을 위한 실기기와 USB 케이블도 치워버리고 SwiftUI 프리뷰와 함께 바로바로 UI 구현 사항을 체크하도록 하자.\n","permalink":"https://bonoogi.github.io/posts/2022/02/01-swiftui-preview-build/","summary":"프로젝트별로 상황이야 다르겠지만, SwiftUI 프리뷰를 사용할 때 빌드하는 시간이 너무 오래 걸리면 \u0026ldquo;야 이거 너무 오래 걸려서 프리뷰 기능을 잠깐 멈췄어. 준비","title":"SwiftUI Preview 빌드가 너무 오래걸려서 써먹을수가 없을때"}]