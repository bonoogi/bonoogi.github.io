<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Hell yeah, World</title><link>https://bonoogi.github.io/</link><description>Recent content on Hell yeah, World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Mar 2022 22:57:09 +0900</lastBuildDate><atom:link href="https://bonoogi.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>[Swift] Combine의 Backpressure 처리</title><link>https://bonoogi.github.io/posts/2022-03-06-combine-backpressure/</link><pubDate>Sun, 06 Mar 2022 22:57:09 +0900</pubDate><guid>https://bonoogi.github.io/posts/2022-03-06-combine-backpressure/</guid><description>Combine이든 RxSwift든 리액티브 프로그래밍 프레임워크를 다루다보면 한번씩 마주하게 되는 문제가 몇가지 있다. 하나는 메모리 관리 문제고(보통 이건 초심자가 많이 겪는다), 또 하나는 배압(Backpressure) 문제다. 리액티브 프로그래밍에서 배압이란 무엇을 말하는가? 구독자와 게시자가 있다고 할 때, 구독자가 값(혹은 이벤트)을 소비하는 속도가 게시자가 값을 보내는 속도를 따라가지 못하는 상황을 일컫는다. 이게 원래는 유체동역학 용어(위키백과: Back Pressure)라는데, 프로그래밍 관점에서 리액티브 프로그래밍이라는게 값의 흐름이니 정말 적절한 용어가 아닌가 싶다.
By Engr.Nithin Mohandas - Own work, CC BY-SA 4.</description></item><item><title>[Swift] Combine 테스트 하기</title><link>https://bonoogi.github.io/posts/2022-02-20-testing-combine/</link><pubDate>Sun, 20 Feb 2022 23:19:41 +0900</pubDate><guid>https://bonoogi.github.io/posts/2022-02-20-testing-combine/</guid><description>원래는 이전 글에서 Combine Scheduler에 대해 좀 더 알아보는 글을 쓰려고 했는데, 방향에 가닥이 잡히질 않아 다른것부터 쓰기로 했다. 뭔고 하니, 바로 Combine 코드를 단위 테스트하는 방법이다. 현재 개발중인 프로젝트에서는 많은 코드를 Combine 기반으로 작성하고 있기 때문에 테스트 코드 역시 Combine에 맞춰서 구현하게 된다. 그렇다면 어떻게 Combine 코드를 테스트할 수 있을까? 공통점 하나와 차이점 하나로 설명해보겠다.
공통점: setUp과 tearDown Combine 테스트라면 당연하게도 Publisher를 구독하고 값을 받거나 종료 이벤트를 받는 시점에 받은 값을 검증해야 할 것이다.</description></item><item><title>NSAttributedString을 AttributedString으로 변환하기</title><link>https://bonoogi.github.io/posts/2022-02-03-convert-nsattributedstring/</link><pubDate>Sun, 13 Feb 2022 23:17:37 +0900</pubDate><guid>https://bonoogi.github.io/posts/2022-02-03-convert-nsattributedstring/</guid><description>iOS 15에서 AttributedString이 추가되면서 일부 SDK 기능을 쓸 때 NSAttributedString 대신에 AttributedString을 사용해야할 때가 있는데, 이게 또 바로바로 호환이 되질 않는다. 아래와 같이 별도의 생성자를 통해 만들어줘야 한다.
let nsAttributedString = NSAttributedString(...) // UIKit 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \.uiKit) // SwiftUI 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \.swiftUI) // AppKit 특성을 뽑아올 때 let attributedString = try AttributedString(nsAttributedString, including: \.</description></item></channel></rss>